目标：
1. 理解sqrt_price 转换为 tick背后的数学原理


内容：
1. math formula
// 目标：从 sqrt_price_x64 计算对应的 tick
// 数学关系：P = 1.0001^tick
// 其中 P 是价格，tick 是价格刻度

计算步骤：
    1.验证边界：确保价格在有效范围内
    2.计算log2整数部分：使用MSB快速计算
    3.归一化：将价格调整到 [1, 2) 范围
    4.迭代计算log2小数部分：使用牛顿迭代法
    5.合并结果：整数部分 + 小数部分
    6.换底转换：从log2转换为log_√1.0001
    7.计算tick范围：考虑计算误差
    8.选择最终tick：验证并选择最准确的值


1.1 验证边界

require!(
    sqrt_price_x64 >= MIN_SQRT_PRICE_X64 && sqrt_price_x64 < MAX_SQRT_PRICE_X64,
    ErrorCode::SqrtPriceX64
);
参数含义：
MIN_SQRT_PRICE_X64 = 4295048016：最小平方根价格（对应 MIN_TICK = -443636）
MAX_SQRT_PRICE_X64 = 79226673521066979257578248091：最大平方根价格（对应 MAX_TICK = 443636）
作用：确保输入价格在有效范围内


1.2 计算整数部分 (MSB)
let msb: u32 = 128 - sqrt_price_x64.leading_zeros() - 1;
let log2p_integer_x32 = (msb as i128 - 64) << 32;
