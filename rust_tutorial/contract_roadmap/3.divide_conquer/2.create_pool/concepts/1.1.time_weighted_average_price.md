目标：
1. 掌握 Time-Weighted Average Price 的计算方法
2. 掌握 其在 observation state的应用


内容：
1. 计算
tick_cumulative = Σ(tick_i × time_duration_i)

1.1 类比
Imagine you're on a road trip, and you want to calculate the average speed you traveled. If you just looked at your speed at different moments (say, 60 mph at one point, 80 mph at another), you wouldn’t get the right sense of your overall journey because your speed varied.

Instead, you could calculate the average speed by considering how long you spent traveling at each speed. If you drove for 1 hour at 60 mph and 1 hour at 80 mph, you would average those two speeds (70 mph). However, if you drove for 3 hours at 60 mph and 1 hour at 80 mph, your overall speed would be closer to 60 mph, because you spent more time driving at 60 mph.

1.2 实例
Let’s say you want to find the Time-Weighted Average Price (TWAP) of a stock over a 4-hour period, and the stock prices at different time intervals are as follows:

9:00 AM to 10:00 AM: $100

10:00 AM to 11:00 AM: $105

11:00 AM to 12:00 PM: $110

12:00 PM to 1:00 PM: $95

Since each time period (1 hour) is equally important, the TWAP would be calculated as the simple average of these prices:

TWAP=4(100+105+110+95)​=4410​=102.5

So, the Time-Weighted Average Price for the day is $102.50.

This method gives equal importance to each time period and helps smooth out any price fluctuations, making it useful for large trades that might span multiple periods.


1.3 代码中的计算方法
else {
    let last_observation = self.observations[observation_index as usize];
    let delta_time = block_timestamp.saturating_sub(last_observation.block_timestamp);
    
    // Only update if enough time has passed (15 seconds minimum)
    if delta_time < OBSERVATION_UPDATE_DURATION_DEFAULT {
        return;
    }
    
    // Calculate the contribution of this tick over time
    let delta_tick_cumulative = i64::from(tick).checked_mul(delta_time.into()).unwrap();
    
    // Move to next observation slot (circular buffer)
    let next_observation_index = if observation_index as usize == OBSERVATION_NUM - 1 {
        0  // Wrap around to beginning
    } else {
        observation_index + 1
    };
    
    // Update the new observation
    self.observations[next_observation_index as usize].block_timestamp = block_timestamp;
    self.observations[next_observation_index as usize].tick_cumulative = 
        last_observation.tick_cumulative.wrapping_add(delta_tick_cumulative);
    
    // Move to next slot
    self.observation_index = next_observation_index;
}



2. 应用
从observation中能够获取什么信息？ 有什么实际作用？ 

