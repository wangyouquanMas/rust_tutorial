目标：
1. 理解tokenStream的定义？
2. 掌握tokenStream的用法
3. 做实验，验证概念及理解

内容：
1. 定义
Analogy 1: Recipe → Cooking Machine → Finished Dish

TokenStream is like a cooking machine that transforms recipes into finished dishes.
The Process:
Recipe (Input TokenStream): You write a simple recipe
Apply to lib.rs
   #[derive(Accounts)]
   pub struct MyAccounts<'info> {
       #[account(mut)]
       pub data: Account<'info, MyData>,
   }
Cooking Machine (Macro Processing): The macro is like a smart cooking machine that:
Reads your recipe
Analyzes the ingredients (attributes, types)
Understands what you want to cook
Finished Dish (Output TokenStream): The machine produces a complete meal
Apply to lib.rs
   // Generated code with validation, error handling, etc.
   impl<'info> Accounts<'info> for MyAccounts<'info> {
       fn try_accounts(...) -> Result<Self> {
           // 50+ lines of validation code
       }
   }
Just like you don't need to know how the cooking machine works internally, you don't need to write all the validation code manually.

1.1 举例
第一步：
CreatePool struct is the TokenStream 
    #[derive(Accounts)]
    pub struct CreatePool<'info> {
        #[account(mut)]
        pub pool_creator: Signer<'info>,

        #[account(
            init,
            seeds = [
                POOL_SEED.as_bytes(),
                amm_config.key().as_ref(),
                token_mint_0.key().as_ref(),
                token_mint_1.key().as_ref(),
            ],
            bump,
            payer = pool_creator,
            space = PoolState::LEN
        )]
        pub pool_state: AccountLoader<'info, PoolState>,
        
        // ... more fields
    }
第二步：
parse_macro_input!(item as anchor_syn::AccountsStruct)

This converts the raw TokenStrem into a structured AccountsStruct object that can be analyzed
and processed. 

举例： What AccountsStruct Contains
pub struct AccountsStruct {
    pub ident: Ident,                    // "CreatePool"
    pub generics: Generics,              // '<'info>'
    pub fields: Vec<AccountField>,       // All the account fields
    instruction_api: Option<...>,        // #[instruction(...)] data
}
其中 Each AccountField contains:
Field name and type
Parsed constraints from #[account(...)] attributes
Validation rules
Account creation logic

第三步： 总结
So the Function Does:
1. Parse: TokenStream → AccountsStruct (structured data)
2. Generate: AccountsStruct → TokenStream (generated code)
It's not just turning one struct into another - it's parsing your struct definition and generating a complete implementation for it.
3. Think of it like:
Input: A blueprint (your struct)
Parse: Understanding the blueprint (AccountsStruct)
Generate: Building the actual structure (generated code)