目标：
1. 基于CLMM池子交易构造过程，来掌握源码实现过程



内容：
1. 交易指令含义及顺序

1.1 set compute unit price 
	computeUnitPriceInstruction := aSDK.NewInstruction(
		aSDK.MustPublicKeyFromBase58("ComputeBudget111111111111111111111111111111"),
		aSDK.AccountMetaSlice{},
		[]byte{3, 159, 217, 5, 0, 0, 0, 0, 0}, // 375000 microlamports
	)
1.2 Set compute unit limit 
   	computeUnitLimitInstruction := aSDK.NewInstruction(
		aSDK.MustPublicKeyFromBase58("ComputeBudget111111111111111111111111111111"),
		aSDK.AccountMetaSlice{},
		[]byte{2, 0, 16, 3, 0, 0, 0, 0}, // 200000 compute units
	)

1.3 .Create the pool creation instruction with the program, accounts, and data
	poolInstruction := aSDK.NewInstruction(
		raydiumProgramID,
		poolAccounts,
		instructionData,
	)


1.3.1 crate pool instruction 包含的账户
    	// 9. Create the account meta slice with ALL accounts needed for the createPool instruction
	// Account order is critical for Raydium instructions
	poolAccounts := aSDK.AccountMetaSlice{
		aSDK.Meta(poolCreator).WRITE().SIGNER(), // [0] poolCreator (owner account that pays for and signs the tx)
		aSDK.Meta(ammConfig),                    // [1] ammConfig (read-only)
		aSDK.Meta(poolStatePDA).WRITE(),         // [2] poolState (write)
		aSDK.Meta(sortedToken0),                 // [3] tokenMint0 (read-only)
		aSDK.Meta(sortedToken1),                 // [4] tokenMint1 (read-only)
		aSDK.Meta(tokenVault0PDA).WRITE(),       // [5] tokenVault0 (write)
		aSDK.Meta(tokenVault1PDA).WRITE(),       // [6] tokenVault1 (write)
		aSDK.Meta(observationStatePDA).WRITE(),  // [7] observationState (write)
		aSDK.Meta(tickArrayBitmapPDA).WRITE(),   // [8] tickArrayBitmap (write)
		aSDK.Meta(aSDK.TokenProgramID),          // [9] tokenProgram0 (read-only)
		aSDK.Meta(aSDK.TokenProgramID),          // [10] tokenProgram1 (read-only)
		aSDK.Meta(aSDK.SystemProgramID),         // [11] systemProgram (read-only)
		aSDK.Meta(aSDK.SysVarRentPubkey),        // [12] rent (read-only)
	}
    账户含义
			
		账户	作用	关键特性
		pool_creator	池创建者，支付创建费用	签名者，可变账户
		amm_config	AMM配置信息	包含tick_spacing等配置
		pool_state	池状态存储	PDA账户，存储池的核心状态
		token_mint_0/1	代币铸币账户	支持不同token程序
		token_vault_0/1	代币金库账户	PDA账户，存储池的代币
		observation_state	价格预言机观察数据	用于TWAP计算
		tick_array_bitmap	Tick数组位图	跟踪已初始化的tick数组

    账户顺序



1.3.2. create pool instruction 包含的账户数据
// First, create the instruction with the correct discriminator for createPool
	// The discriminator for Raydium CLMM createPool is {233, 146, 209, 142, 207, 104, 64, 188}
	instructionData := []byte{233, 146, 209, 142, 207, 104, 64, 188}

// Next, encode sqrtPriceX64 as a 16-byte (128-bit) big-endian unsigned integer
	// We need to carefully handle endianness here
	sqrtPriceX64Int := sqrtPriceX64.BigInt()
	sqrtPriceX64Bytes := make([]byte, 16)
	// Ensure we have proper big-endian representation
	sqrtBytes := sqrtPriceX64Int.Bytes()
	// Handle the case where sqrtBytes might be larger than 16 bytes
	if len(sqrtBytes) > 16 {
		// Take only the last 16 bytes (least significant) if larger
		copy(sqrtPriceX64Bytes, sqrtBytes[len(sqrtBytes)-16:])
	} else {
		// Pad with leading zeros if smaller
		copy(sqrtPriceX64Bytes[16-len(sqrtBytes):], sqrtBytes)
	}
	logx.WithContext(ctx).Infof("SqrtPriceX64 bytes (hex): %x", sqrtPriceX64Bytes)
	instructionData = append(instructionData, sqrtPriceX64Bytes...)

// Finally, encode openTime as a 8-byte (64-bit) little-endian unsigned integer
	// Raydium uses little-endian encoding for the timestamp
	openTimeBytes := make([]byte, 8)
	openTime := uint64(createPoolTx.OpenTime)
	binary.LittleEndian.PutUint64(openTimeBytes, openTime)

	logx.WithContext(ctx).Infof("OpenTime bytes (hex): %x", openTimeBytes)
	instructionData = append(instructionData, openTimeBytes...)

    账户数据包含：
    1. discriminator 
    2. sqrtPriceX64Bytes ? 
    3. openTimeBytes  ?