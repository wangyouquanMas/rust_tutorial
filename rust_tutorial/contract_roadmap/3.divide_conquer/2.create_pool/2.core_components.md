目标：
1. 基于CLMM池子交易构造过程，来掌握源码实现过程



内容：
1. 交易指令含义及顺序

1.1 set compute unit price 
	computeUnitPriceInstruction := aSDK.NewInstruction(
		aSDK.MustPublicKeyFromBase58("ComputeBudget111111111111111111111111111111"),
		aSDK.AccountMetaSlice{},
		[]byte{3, 159, 217, 5, 0, 0, 0, 0, 0}, // 375000 microlamports
	)
1.2 Set compute unit limit 
   	computeUnitLimitInstruction := aSDK.NewInstruction(
		aSDK.MustPublicKeyFromBase58("ComputeBudget111111111111111111111111111111"),
		aSDK.AccountMetaSlice{},
		[]byte{2, 0, 16, 3, 0, 0, 0, 0}, // 200000 compute units
	)

1.3 .Create the pool creation instruction with the program, accounts, and data
	poolInstruction := aSDK.NewInstruction(
		raydiumProgramID,
		poolAccounts,
		instructionData,
	)


1.3.1 crate pool instruction 包含的账户
    	// 9. Create the account meta slice with ALL accounts needed for the createPool instruction
	// Account order is critical for Raydium instructions
	poolAccounts := aSDK.AccountMetaSlice{
		aSDK.Meta(poolCreator).WRITE().SIGNER(), // [0] poolCreator (owner account that pays for and signs the tx)
		aSDK.Meta(ammConfig),                    // [1] ammConfig (read-only)
		aSDK.Meta(poolStatePDA).WRITE(),         // [2] poolState (write)
		aSDK.Meta(sortedToken0),                 // [3] tokenMint0 (read-only)
		aSDK.Meta(sortedToken1),                 // [4] tokenMint1 (read-only)
		aSDK.Meta(tokenVault0PDA).WRITE(),       // [5] tokenVault0 (write)
		aSDK.Meta(tokenVault1PDA).WRITE(),       // [6] tokenVault1 (write)
		aSDK.Meta(observationStatePDA).WRITE(),  // [7] observationState (write)
		aSDK.Meta(tickArrayBitmapPDA).WRITE(),   // [8] tickArrayBitmap (write)
		aSDK.Meta(aSDK.TokenProgramID),          // [9] tokenProgram0 (read-only)
		aSDK.Meta(aSDK.TokenProgramID),          // [10] tokenProgram1 (read-only)
		aSDK.Meta(aSDK.SystemProgramID),         // [11] systemProgram (read-only)
		aSDK.Meta(aSDK.SysVarRentPubkey),        // [12] rent (read-only)
	}
    账户含义
        poolCreator： 3xbCoRgPcuUhUdsVJHrq79gmcGUT3VwqrHgMTkV296cP 【write signer】
        ammConfig: FiyUUSnhBgLhBgVGWNBVozhzSbAbFCU1Q8iWMHH3xUhA  [?]
        poolStatePDA：4WuMZkKj1adTBnn2cRQLd75tEFYg8om5qomfoRJogjm4   【池子地址】
        tokenMint0： So11111111111111111111111111111111111111112   【？什么顺序】
        tokenMint1： F3mx1gU8C8vCitMrZc1XAcYt77cSPxaCmSbpBdqAkjjT  
        tokenVault0：5tyg87BRaizWezda6s8f2B5rfkXEVLMosWTkvzgLk92p   【Pool PDA】
        tokenVault1： 2tvfSUQqg68t2YWu7Jz5m2p5sMgHikNB29SW4FVSXcVd   
        observationState: AHjWHaokdPDit9cBRCy4L79oWRH37vCFxchEQkXUsNV [?]
        tickArrayBitmap: DukbpBVK7kK3UwVPpzmeQdETM3QZQ3phUXYXNgiRTmrd [?]
        tokenProgram0: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA
        tokenProgram1: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA
        systemProgram: 11111111111111111111111111111111
        rent: SysvarRent111111111111111111111111111111111  [?]

    账户顺序



1.3.2. create pool instruction 包含的账户数据
// First, create the instruction with the correct discriminator for createPool
	// The discriminator for Raydium CLMM createPool is {233, 146, 209, 142, 207, 104, 64, 188}
	instructionData := []byte{233, 146, 209, 142, 207, 104, 64, 188}

// Next, encode sqrtPriceX64 as a 16-byte (128-bit) big-endian unsigned integer
	// We need to carefully handle endianness here
	sqrtPriceX64Int := sqrtPriceX64.BigInt()
	sqrtPriceX64Bytes := make([]byte, 16)
	// Ensure we have proper big-endian representation
	sqrtBytes := sqrtPriceX64Int.Bytes()
	// Handle the case where sqrtBytes might be larger than 16 bytes
	if len(sqrtBytes) > 16 {
		// Take only the last 16 bytes (least significant) if larger
		copy(sqrtPriceX64Bytes, sqrtBytes[len(sqrtBytes)-16:])
	} else {
		// Pad with leading zeros if smaller
		copy(sqrtPriceX64Bytes[16-len(sqrtBytes):], sqrtBytes)
	}
	logx.WithContext(ctx).Infof("SqrtPriceX64 bytes (hex): %x", sqrtPriceX64Bytes)
	instructionData = append(instructionData, sqrtPriceX64Bytes...)

// Finally, encode openTime as a 8-byte (64-bit) little-endian unsigned integer
	// Raydium uses little-endian encoding for the timestamp
	openTimeBytes := make([]byte, 8)
	openTime := uint64(createPoolTx.OpenTime)
	binary.LittleEndian.PutUint64(openTimeBytes, openTime)

	logx.WithContext(ctx).Infof("OpenTime bytes (hex): %x", openTimeBytes)
	instructionData = append(instructionData, openTimeBytes...)

    账户数据包含：
    1. discriminator 
    2. sqrtPriceX64Bytes ? 
    3. openTimeBytes  ?