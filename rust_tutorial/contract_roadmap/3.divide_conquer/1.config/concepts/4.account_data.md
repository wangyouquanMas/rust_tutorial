问题：AmmConfig 数据是如何写入到 Account中的data字段的？ 

答案：
1）Anchor框架自动处理
// Anchor框架内部处理流程：
1. #[account(init)] 宏触发账户初始化
2. 分配 AmmConfig::LEN 字节的存储空间
3. 在账户的 data 字段中预留空间
4. 当执行 amm_config.field = value 时，自动序列化到 data 字段

2）序列化过程
// Anchor使用Borsh序列化库：
// 1. 账户discriminator (8字节)
// 2. 结构体字段按顺序序列化
// 3. 每个字段使用little-endian编码
// 4. 最终写入Account.data字段

3）具体存储位置
// Solana Account结构
pub struct Account {
    pub lamports: u64,
    pub data: Vec<u8>,        // ← AmmConfig数据存储在这里
    pub owner: Pubkey,
    pub executable: bool,
    pub rent_epoch: Epoch,
}

4） 数据布局 【Data layout】
// Account.data字段的内容布局：
[
    // 0-7: Anchor账户discriminator (8字节)
    0x89, 0x34, 0xed, 0xd4, 0xd7, 0x75, 0x6c, 0x68,
    
    // 8: bump (1字节)
    0xFF,
    
    // 9-10: index (2字节，小端序)
    0x01, 0x00,
    
    // 11-42: owner (32字节)
    0x...,
    
    // 43-46: protocol_fee_rate (4字节，小端序)
    0xB0, 0x04, 0x00, 0x00,
    
    // 47-50: trade_fee_rate (4字节，小端序)
    0xB8, 0x0B, 0x00, 0x00,
    
    // 51-52: tick_spacing (2字节，小端序)
    0x3C, 0x00,
    
    // 53-56: fund_fee_rate (4字节，小端序)
    0x00, 0x00, 0x00, 0x00,
    
    // 57-60: padding_u32 (4字节)
    0x00, 0x00, 0x00, 0x00,
    
    // 61-92: fund_owner (32字节)
    0x...,
    
    // 93-116: padding (24字节)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
]


总结： 自动化过程
Anchor框架自动处理以下步骤：
1. 账户创建: #[account(init)] 创建新账户
2. 空间分配: space = AmmConfig::LEN 分配存储空间
3. 数据序列化: 当访问结构体字段时自动序列化
4. 数据存储: 将序列化数据写入 Account.data 字段
5. 这就是AmmConfig数据如何存储到Account data字段的完整过程。


