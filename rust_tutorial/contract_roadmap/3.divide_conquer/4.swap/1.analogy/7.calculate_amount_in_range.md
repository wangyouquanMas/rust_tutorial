目标：
1. 掌握calculate_amount_in_range函数的作用



内容：
1. 作用
The calculate_amount_in_range function serves as a pre-calculation validator that determines whether a swap step can reach its target price. 

Primary Purpose
    This function pre-calculates the amount needed to move from the current price to a target price within a specific liquidity range. It acts as a feasibility check before executing the actual swap step.


1) Pre-Execution Validation
let amount_in = calculate_amount_in_range(
    sqrt_price_current_x64,
    sqrt_price_target_x64,
    liquidity,
    zero_for_one,
    is_base_input,
    block_timestamp,
)?;
What it does:
    Checks feasibility: Can we reach the target price with current liquidity?
    Prevents overflow: Identifies cases where amounts would exceed u64 limits
    Optimizes execution: Determines if we can do a full step or partial step

2) Two Calculation Modes
For Base Input (Exact Input Mode)
if is_base_input {
    let result = if zero_for_one {
        liquidity_math::get_delta_amount_0_unsigned(
            sqrt_price_target_x64,
            sqrt_price_current_x64,
            liquidity,
            true,
        )
    } else {
        liquidity_math::get_delta_amount_1_unsigned(
            sqrt_price_current_x64,
            sqrt_price_target_x64,
            liquidity,
            true,
        )
    };
}
Purpose: Calculate how much input is needed to reach target price
/// * `Δx = L * (1 / √P_lower - 1 / √P_upper)`
/// * i.e. `L * (√P_upper - √P_lower) / (√P_upper * √P_lower)`


For Quote Input (Exact Output Mode)
} else {
    let result = if zero_for_one {
        liquidity_math::get_delta_amount_1_unsigned(
            sqrt_price_target_x64,
            sqrt_price_current_x64,
            liquidity,
            false,
        )
    } else {
        liquidity_math::get_delta_amount_0_unsigned(
            sqrt_price_current_x64,
            sqrt_price_target_x64,
            liquidity,
            false,
        )
    };
}
Purpose: Calculate how much output can be generated within the price range


3) Overflow Protection
MaxTokenOverflow Handling
if result.is_ok() {
    return Ok(Some(result.unwrap()));
} else {
    if result.err().unwrap() == crate::error::ErrorCode::MaxTokenOverflow.into() {
        return Ok(None);  // Return None instead of error
    } else {
        return Err(ErrorCode::SqrtPriceLimitOverflow.into());
    }
}
What this means:
    Ok(Some(amount)): Target price is reachable
    Ok(None): Amount would overflow u64, target price not reachable
    Err(...): Other errors (like invalid price range)

