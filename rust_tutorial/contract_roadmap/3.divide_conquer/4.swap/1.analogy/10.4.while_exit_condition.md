目标：
1. 掌握在单个tickArray，单个tick情况下，while循环的退出情况


内容：
1. 退出条件
通过打印日志发现： 在该条件下推出的原因是因为 amount_specified_remaining =0 ,被消耗光了
  while state.amount_specified_remaining != 0 && state.sqrt_price_x64 != sqrt_price_limit_x64 {
    ...
  }
> Program log: state.amount_specified_remaining != 0: false
> Program log: state.sqrt_price_x64 != sqrt_price_limit_x64: true


1.1 查看下amount_specified_remaining 被消耗的过程实例
命令：/target/release/client swap 5Kar97KcLTHFP7iMMbRgB74zXHVL43yEmURwD3Z6RvdT  234tz8eCkuyN6Sjavgiry5jco45UL6VzENW9J7csvP5U --base-in 10000

执行过程：
if is_base_input {
            msg!("is_base_input");
            //10000
            msg!("state.amount_specified_remaining: {}", state.amount_specified_remaining);
            //9970
            msg!("step.amount_in: {}", step.amount_in);
            //30
            msg!("step.fee_amount: {}", step.fee_amount);
            state.amount_specified_remaining = state
                .amount_specified_remaining
                .checked_sub(step.amount_in + step.fee_amount)
                .unwrap();
            //0
            msg!("state.amount_specified_remaining after: {}", state.amount_specified_remaining);
            state.amount_calculated = state
                .amount_calculated
                .checked_add(step.amount_out)
                .unwrap();
            //8
            msg!("state.amount_calculated: {}", state.amount_calculated);
}

查看下，10000的剩余是怎么被消耗的？ 
      state.amount_specified_remaining = state
                .amount_specified_remaining
                .checked_sub(step.amount_in + step.fee_amount)
                .unwrap();
step.amount_in = 9700
step.fee_amount = 30

进一步，查看amount_in 在当前的swap_step中是怎么计算出来的？
    let swap_step = swap_math::compute_swap_step(
            step.sqrt_price_start_x64,
            target_price,
            state.liquidity,
            state.amount_specified_remaining,
            amm_config.trade_fee_rate,
            is_base_input,
            zero_for_one,
            block_timestamp,
        )?;
注意这里的两个价格是： 
step.sqrt_price_start_x64 [current tick price] 和 target_price 【next tick的price】
问题：这里面的两个price是怎么计算出来的？ 和LP的price range以及其对应的tick的关系？
target_price = step.sqrt_price_next_x64 = tick_math::get_sqrt_price_at_tick(step.tick_next)?;
        
        //state.tick: -71250
        msg!("state.tick: {}", state.tick);
         let mut next_initialized_tick = if let Some(tick_state) = tick_array_current
            .next_initialized_tick(state.tick, pool_state.tick_spacing, zero_for_one)?
        {
            //111
            msg!("111");
            Box::new(*tick_state)
        } else {
            msg!("222");
            if !is_match_pool_current_tick_array {
                is_match_pool_current_tick_array = true;
                Box::new(*tick_array_current.first_initialized_tick(zero_for_one)?)
            } else {
                Box::new(TickState::default())
            }
        };

        step.tick_next = next_initialized_tick.tick;
        //0step.tick_next: -71340
        msg!("0step.tick_next: {}", step.tick_next);
        step.initialized = next_initialized_tick.is_initialized();
        //step.initialized: true
        msg!("step.initialized: {}", step.initialized);

        if step.tick_next < tick_math::MIN_TICK {
            step.tick_next = tick_math::MIN_TICK;
            msg!("1step.tick_next: {}", step.tick_next);
        } else if step.tick_next > tick_math::MAX_TICK {
            step.tick_next = tick_math::MAX_TICK;
            msg!("2step.tick_next: {}", step.tick_next);
        }
        step.sqrt_price_next_x64 = tick_math::get_sqrt_price_at_tick(step.tick_next)?;

        let target_price = if (zero_for_one && step.sqrt_price_next_x64 < sqrt_price_limit_x64)
            || (!zero_for_one && step.sqrt_price_next_x64 > sqrt_price_limit_x64)
        {
            msg!("target_price1: {}", sqrt_price_limit_x64);
            sqrt_price_limit_x64
        } else {
            //target_price2: 521037230575395660
            msg!("target_price2: {}", step.sqrt_price_next_x64);
            step.sqrt_price_next_x64
        };

问题：哪个这些tick的？ 目前我理解不应该只有3个tick吗？ pool price对应的tick, position price lower对应的tick和position price upper对应的tick. 

这个state.tick: -71250  是 pool_state.tick_current, 
下一个是 -71340 ，这个是 open position时候，ticklowerprice对应的index. 可以做实验验证下：
tickLower (index): -71340
tickUpper (index): -66480
通过打印日志发现是的。 


仔细阅读：compute_swap_step代码
 if zero_for_one {
        msg!("111zero_for_one");
        // if max is reached for exact input case, entire amount_in is needed
        if !(max && is_base_input) {
            swap_step.amount_in = liquidity_math::get_delta_amount_0_unsigned(
                swap_step.sqrt_price_next_x64,
                sqrt_price_current_x64,
                liquidity,
                true,
            )?;
            //swap_step.amount_in: 9970
            msg!("swap_step.amount_in: {:?}", swap_step.amount_in);
        };
        // if max is reached for exact output case, entire amount_out is needed
        if !(max && !is_base_input) {
            swap_step.amount_out = liquidity_math::get_delta_amount_1_unsigned(
                swap_step.sqrt_price_next_x64,
                sqrt_price_current_x64,
                liquidity,
                false,
            )?;
            //swap_step.amount_out: 8
            msg!("swap_step.amount_out: {:?}", swap_step.amount_out);
        };
    }

    计算公式如下：`Δx = L * (1 / √P_lower - 1 / √P_upper)` = L * (√P_upper - √P_lower) / (√P_upper * √P_lower)
    其中L 是liquidity ;  

    这里的liquidity 是池子的liquidity :     let liquidity_start = pool_state.liquidity;

下面的计算是在知道池子的流动性和价格范围（池子当前价格和池子的lower price）和方向的前提下，可以计算出所需的amount0/1的真实数量。 
1. 当前价格到下限价格之间的 amount0
Δx = L × (1/√P_current - 1/√P_lower)
这表示：从当前价格下跌到下限价格时，需要多少 token0 来维持这个流动性 L = sqrt(x*y) [在swap的时候，L是不变的，所以为了维持L不变，当价格变化的时候，就需要输入特定数量的deltax,或者deltay来维持其不变性]
举例：
2. 实际意义：TODO: 示例 
如果当前价格是 $1000，下限价格是 $900
流动性是 1000
函数会计算出：当价格从 $1000 跌到 $900 时，需要多少 token0。 参考下面图，也就是说
当价格从P点下降到P_lower点，我们需要添加多少的token0 ? 这里也就是我们的deltax  = x_(p_lower) - x_p = 
L/sqrt(P_lower) - L/sqrt(p_current) = L*(sqrt(p_lower)-sqrt(p_current)) = L*(sqrt(p_current) - sqrt(p_lower)) / (sqrt(p_lower)*sqrt(p_current))
对应到代码中： 
swap_step.sqrt_price_next_x64, 是p_lower  ； 
sqrt_price_current_x64, 是p_current ； 
其中p_lower < p_current. 


查看计算过程：
pub fn get_delta_amount_0_unsigned(
    mut sqrt_ratio_a_x64: u128,
    mut sqrt_ratio_b_x64: u128,
    liquidity: u128,
    round_up: bool,
) -> Result<u64> {
    msg!("calculate delta amount0");
    //532513227945088305
    msg!("sqrt_ratio_a_x64: {}", sqrt_ratio_a_x64);
    //536764713671534825
    msg!("sqrt_ratio_b_x64: {}", sqrt_ratio_b_x64);
    //36337
    msg!("liquidity: {}", liquidity);
    //true
    msg!("round_up: {}", round_up);

    // sqrt_ratio_a_x64 should hold the smaller value
    if sqrt_ratio_a_x64 > sqrt_ratio_b_x64 {
        msg!("sqrt_ratio_a_x64 > sqrt_ratio_b_x64");
        std::mem::swap(&mut sqrt_ratio_a_x64, &mut sqrt_ratio_b_x64);
    };

    //670299339406383977070592
    let numerator_1 = U256::from(liquidity) << fixed_point_64::RESOLUTION;
    //4251485726446520
    let numerator_2 = U256::from(sqrt_ratio_b_x64 - sqrt_ratio_a_x64);
    msg!("numerator_1: {}", numerator_1);
    msg!("numerator_2: {}", numerator_2);

    assert!(sqrt_ratio_a_x64 > 0);
    //sqrt_ratio_a_x64 >0
    msg!("sqrt_ratio_a_x64 > 0");

    let result = if round_up {
        //round_up
        msg!("round_up");
        //公式：result = ⌈(numerator_1 × numerator_2) / sqrt_ratio_b_x64⌉ / sqrt_ratio_a_x64
        U256::div_rounding_up(
            numerator_1
                .mul_div_ceil(numerator_2, U256::from(sqrt_ratio_b_x64))
                .unwrap(),
            U256::from(sqrt_ratio_a_x64),
        )
    } else {
        numerator_1
            .mul_div_floor(numerator_2, U256::from(sqrt_ratio_b_x64))
            .unwrap()
            / U256::from(sqrt_ratio_a_x64)
    };

    //9970
    msg!("result: {:?}", result);

    if result > U256::from(u64::MAX) {
        return Err(ErrorCode::MaxTokenOverflow.into());
    }

    println!("get_delta_amount_0_unsigned result: {}", result);

    return Ok(result.as_u64());
}