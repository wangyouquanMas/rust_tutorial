目标：
1. 理解Execute Step: Swap until reaching the next tick or exhausting amount




内容：
1. 执行过程



1.1. 代码
// Main swap loop - continues until amount is exhausted or price limit is reached
while state.amount_specified_remaining != 0 && state.sqrt_price_x64 != sqrt_price_limit_x64 {
    let mut step = StepComputations::default();
    step.sqrt_price_start_x64 = state.sqrt_price_x64;
    
    // Find the next initialized tick to cross
    let mut next_initialized_tick = tick_array_current
        .next_initialized_tick(state.tick, pool_state.tick_spacing, zero_for_one)?;
    
    // If no more ticks in current array, move to next tick array
    if !next_initialized_tick.is_initialized() {
        let next_initialized_tickarray_index = pool_state
            .next_initialized_tick_array_start_index(
                &tickarray_bitmap_extension,
                current_vaild_tick_array_start_index,
                zero_for_one,
            )?;
        // Load next tick array...
    }
    
    // Set target price for this step
    step.tick_next = next_initialized_tick.tick;
    step.sqrt_price_next_x64 = tick_math::get_sqrt_price_at_tick(step.tick_next)?;
    
    // Execute the swap step
    let swap_step = swap_math::compute_swap_step(
        step.sqrt_price_start_x64,
        target_price,
        state.liquidity,
        state.amount_specified_remaining,
        amm_config.trade_fee_rate,
        is_base_input,
        zero_for_one,
        block_timestamp,
    )?;
    
    // Update state after swap step
    state.sqrt_price_x64 = swap_step.sqrt_price_next_x64;
    // ... update amounts and fees
}