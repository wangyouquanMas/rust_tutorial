目标：
1. 理解How user's input is processed in the swap process ?



内容：
1. input processing 过程





1） 代码
#[derive(Debug)]
pub struct SwapState {
    // the amount remaining to be swapped in/out of the input/output asset
    pub amount_specified_remaining: u64,
    // the amount already swapped out/in of the output/input asset
    pub amount_calculated: u64,
    // current sqrt(price)
    pub sqrt_price_x64: u128,
    // the tick associated with the current price
    pub tick: i32,
    // the current liquidity in range
    pub liquidity: u128,
}



2） 实例
Initial State
    User Input: 1000 USDC
    Current Price: $100 USDC per SOL
    Current Liquidity: L = 1,000,000
    Current Tick: 1000

Loop Iteration 1
    Next Tick: 1001 (price: $99.50)
    Available Liquidity: L = 1,000,000

    Swap Step Calculation:
    - Input Processed: 300 USDC
    - Output Generated: 3.02 SOL
    - Fee: 0.9 USDC
    - New Price: $99.50

    State Update:
    - amount_specified_remaining: 1000 - 300 - 0.9 = 699.1 USDC
    - amount_calculated: 0 + 3.02 = 3.02 SOL
    - Current Price: $99.50

Loop Iteration 2
    Next Tick: 1002 (price: $99.00)
    Available Liquidity: L = 950,000 (changed at tick 1001)

    Swap Step Calculation:
    - Input Processed: 250 USDC
    - Output Generated: 2.53 SOL
    - Fee: 0.75 USDC
    - New Price: $99.00

    State Update:
    - amount_specified_remaining: 699.1 - 250 - 0.75 = 448.35 USDC
    - amount_calculated: 3.02 + 2.53 = 5.55 SOL
    - Current Price: $99.00

Loop Continues Until...
    All input consumed: amount_specified_remaining = 0
    Price limit hit: Reached user's maximum slippage
    Liquidity exhausted: No more initialized ticks


3) 每个tick 消耗的input 数量，是由什么决定的？
amount_in = L × (1/√P₁ - 1/√P₂)  // 对于 zero_for_one
amount_in = L × (√P₂ - √P₁)       // 对于 one_for_zero
影响因素详解
1. 流动性影响
if step.initialized {
    let mut liquidity_net = next_initialized_tick.liquidity_net;
    if zero_for_one {
        liquidity_net = liquidity_net.neg();
    }
    state.liquidity = liquidity_math::add_delta(state.liquidity, liquidity_net).unwrap();
}
流动性变化的影响：
    流动性增加 → 每个tick能处理更多input
    流动性减少 → 每个tick能处理的input减少


2. 价格变化影响
step.sqrt_price_next_x64 = tick_math::get_sqrt_price_at_tick(step.tick_next).unwrap();
价格变化的影响：
    Tick间距大 → 价格变化大 → 每个tick消耗更多input
    Tick间距小 → 价格变化小 → 每个tick消耗较少input
