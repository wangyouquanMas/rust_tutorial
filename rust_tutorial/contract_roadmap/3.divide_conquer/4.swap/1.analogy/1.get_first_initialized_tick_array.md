目标：
1. 掌握get_first_initialized_tick_array的计算方法
2. 理解tickarray_bitmap_extension在寻找 first initialized tick array中的作用


内容：
1. 计算方法




1.1) 代码
/// Given a tick, calculate whether the tickarray it belongs to has been initialized.
/// Note: The caller of the function should ensure that tick_current is within the range represented by bit_map.
/// Currently, this function is only called when `bit_map = pool.tick_array_bitmap`.
pub fn check_current_tick_array_is_initialized(
    bit_map: U1024,
    tick_current: i32,
    tick_spacing: u16,
) -> Result<(bool, i32)> {
    if TickState::check_is_out_of_boundary(tick_current) {
        return err!(ErrorCode::InvalidTickIndex);
    }
    let multiplier = i32::from(tick_spacing) * TICK_ARRAY_SIZE;
    let mut compressed = tick_current / multiplier + 512;
    if tick_current < 0 && tick_current % multiplier != 0 {
        // round towards negative infinity
        compressed -= 1;
    }
    let bit_pos = compressed.abs();
    // set current bit
    let mask = U1024::one() << bit_pos.try_into().unwrap();
    let masked = bit_map & mask;
    // check the current bit whether initialized
    let initialized = masked != U1024::default();
    if initialized {
        return Ok((true, (compressed - 512) * multiplier));
    }
    // the current bit is not initialized
    return Ok((false, (compressed - 512) * multiplier));
}

2. 作用