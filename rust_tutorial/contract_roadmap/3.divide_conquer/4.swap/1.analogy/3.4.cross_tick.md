目标：
1. 理解Cross Tick: When price reaches tick boundary逻辑



内容：
1. cross tick过程
参考：https://uniswapv3book.com/milestone_3/cross-tick-swaps.html
A common Uniswap V3 Pool is a pool with many overlapping price ranges. Each pool tracks current sqrt(P) and tick. 
When users swap tokens they move the current price and tick to the left or the right, depening on the swap direction. These movements are caused by tokens being added or removed from pools during swaps. 

Pools alsow track L（Liquidity variable in our code）, which is the total liquidity provided by all price ranges that include the current price. It's expected that, during big price moves, the current price moves outside of price ranges. When this happens, such price ranges become inactive and their liquidity get subtracted from L. On the other hand, when the current price enteres a price range, L is increased and the price range gets actived. 


问题：什么时候进行cross tick ?
shift tick if we reached the next price 
if state.sqrt_price_x64 == step.sqrt_price_next_x64{
    ...
}

问题：current price 和 next price在代码中用什么数据结构表示？  
current: state.sqrt_price_x64, 
next:  step.sqrt_price_next_x64

这里的state是 swap state 
// the top level state of the swap, the results of which are recorded in storage at the end
#[derive(Debug)]
pub struct SwapState {
    // the amount remaining to be swapped in/out of the input/output asset
    pub amount_specified_remaining: u64,
    // the amount already swapped out/in of the output/input asset
    pub amount_calculated: u64,
    // current sqrt(price)
    pub sqrt_price_x64: u128,
    // the tick associated with the current price
    pub tick: i32,
    // the current liquidity in range
    pub liquidity: u128,
    ...
}


这里的step是获取了 next tick的 price 
step.sqrt_price_next_x64 = tick_math::get_sqrt_price_at_tick(step.tick_next)?;
whete tick_next is :
step.tick_next = next_initialized_tick.tick;
where next_initialized_tick is:  [TODO: ]
let mut next_initialized_tick = if let Some(tick_state) = tick_array_current
            .next_initialized_tick(state.tick, pool_state.tick_spacing, zero_for_one)?


问题：如果已经达到 next price的边界, 意味着什么？后续要做什么事情？
意味着：


后续： next_initialized_tick.cross





问题： 接下来做什么事情？ 







1.1 代码
// Check if we've reached the next tick
if state.sqrt_price_x64 == step.sqrt_price_next_x64 {
    // If the tick is initialized, run the tick transition
    if step.initialized {
        msg!("loading next tick {}", step.tick_next);
        
        // Cross the tick and get liquidity net change
        let mut liquidity_net = next_initialized_tick.cross(
            if zero_for_one {
                state.fee_growth_global_x64
            } else {
                pool_state.fee_growth_global_0_x64
            },
            if zero_for_one {
                pool_state.fee_growth_global_1_x64
            } else {
                state.fee_growth_global_x64
            },
            &updated_reward_infos,
        );
        
        // Update tick state in tick array
        tick_array_current.update_tick_state(
            next_initialized_tick.tick,
            pool_state.tick_spacing.into(),
            *next_initialized_tick,
        )?;
        
        // Update pool liquidity based on direction
        if zero_for_one {
            liquidity_net = liquidity_net.neg();
        }
        state.liquidity = liquidity_math::add_delta(state.liquidity, liquidity_net)?;
    }
    
    // Update current tick
    state.tick = if zero_for_one {
        step.tick_next - 1
    } else {
        step.tick_next
    };
}



1.2）代码：cross的时候做什么事情？
Tick State Cross Function
The cross function in TickState handles the actual tick transition:
pub fn cross(
    &mut self,
    fee_growth_global_0_x64: u128,
    fee_growth_global_1_x64: u128,
    reward_infos: &[RewardInfo; REWARD_NUM],
) -> i128 {
    // Update fee growth outside values
    self.fee_growth_outside_0_x64 = fee_growth_global_0_x64
        .checked_sub(self.fee_growth_outside_0_x64)
        .unwrap();
    self.fee_growth_outside_1_x64 = fee_growth_global_1_x64
        .checked_sub(self.fee_growth_outside_1_x64)
        .unwrap();
    
    // Update reward growth outside values
    for i in 0..REWARD_NUM {
        if !reward_infos[i].initialized() {
            continue;
        }
        self.reward_growths_outside_x64[i] = reward_infos[i]
            .reward_growth_global_x64
            .checked_sub(self.reward_growths_outside_x64[i])
            .unwrap();
    }
    
    // Return the liquidity net change
    self.liquidity_net
}


1.3 Liquidity Updates During Tick Crossings
The key insight is that liquidity changes when crossing ticks:

// When crossing a tick, update pool liquidity
if step.initialized {
    let mut liquidity_net = next_initialized_tick.cross(...);
    
    // For zero_for_one swaps, negate the liquidity net
    if zero_for_one {
        liquidity_net = liquidity_net.neg();
    }
    
    // Add the liquidity delta to current pool liquidity
    state.liquidity = liquidity_math::add_delta(state.liquidity, liquidity_net)?;
}

