目标：
1. 理解Cross Tick: When price reaches tick boundary逻辑



内容：
1. cross tick过程
参考：https://uniswapv3book.com/milestone_3/cross-tick-swaps.html
A common Uniswap V3 Pool is a pool with many overlapping price ranges. Each pool tracks current sqrt(P) and tick. 
When users swap tokens they move the current price and tick to the left or the right, depening on the swap direction. These movements are caused by tokens being added or removed from pools during swaps. 

Pools alsow track L（Liquidity variable in our code）, which is the total liquidity provided by all price ranges that include the current price. It's expected that, during big price moves, the current price moves outside of price ranges. When this happens, such price ranges become inactive and their liquidity get subtracted from L. On the other hand, when the current price enteres a price range, L is increased and the price range gets actived. 


问题： 如果已经达到 next price的边界？接下来做什么事情？ 






1.1 代码
// Check if we've reached the next tick
if state.sqrt_price_x64 == step.sqrt_price_next_x64 {
    // If the tick is initialized, run the tick transition
    if step.initialized {
        msg!("loading next tick {}", step.tick_next);
        
        // Cross the tick and get liquidity net change
        let mut liquidity_net = next_initialized_tick.cross(
            if zero_for_one {
                state.fee_growth_global_x64
            } else {
                pool_state.fee_growth_global_0_x64
            },
            if zero_for_one {
                pool_state.fee_growth_global_1_x64
            } else {
                state.fee_growth_global_x64
            },
            &updated_reward_infos,
        );
        
        // Update tick state in tick array
        tick_array_current.update_tick_state(
            next_initialized_tick.tick,
            pool_state.tick_spacing.into(),
            *next_initialized_tick,
        )?;
        
        // Update pool liquidity based on direction
        if zero_for_one {
            liquidity_net = liquidity_net.neg();
        }
        state.liquidity = liquidity_math::add_delta(state.liquidity, liquidity_net)?;
    }
    
    // Update current tick
    state.tick = if zero_for_one {
        step.tick_next - 1
    } else {
        step.tick_next
    };
}



1.2）代码：cross的时候做什么事情？
Tick State Cross Function
The cross function in TickState handles the actual tick transition:
pub fn cross(
    &mut self,
    fee_growth_global_0_x64: u128,
    fee_growth_global_1_x64: u128,
    reward_infos: &[RewardInfo; REWARD_NUM],
) -> i128 {
    // Update fee growth outside values
    self.fee_growth_outside_0_x64 = fee_growth_global_0_x64
        .checked_sub(self.fee_growth_outside_0_x64)
        .unwrap();
    self.fee_growth_outside_1_x64 = fee_growth_global_1_x64
        .checked_sub(self.fee_growth_outside_1_x64)
        .unwrap();
    
    // Update reward growth outside values
    for i in 0..REWARD_NUM {
        if !reward_infos[i].initialized() {
            continue;
        }
        self.reward_growths_outside_x64[i] = reward_infos[i]
            .reward_growth_global_x64
            .checked_sub(self.reward_growths_outside_x64[i])
            .unwrap();
    }
    
    // Return the liquidity net change
    self.liquidity_net
}


1.3 Liquidity Updates During Tick Crossings
The key insight is that liquidity changes when crossing ticks:

// When crossing a tick, update pool liquidity
if step.initialized {
    let mut liquidity_net = next_initialized_tick.cross(...);
    
    // For zero_for_one swaps, negate the liquidity net
    if zero_for_one {
        liquidity_net = liquidity_net.neg();
    }
    
    // Add the liquidity delta to current pool liquidity
    state.liquidity = liquidity_math::add_delta(state.liquidity, liquidity_net)?;
}

