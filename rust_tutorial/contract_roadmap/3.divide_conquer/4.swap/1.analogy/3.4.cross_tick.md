目标：
1. 理解Cross Tick: When price reaches tick boundary逻辑



内容：
1. cross tick过程

1.1 代码
// Check if we've reached the next tick
if state.sqrt_price_x64 == step.sqrt_price_next_x64 {
    // If the tick is initialized, run the tick transition
    if step.initialized {
        msg!("loading next tick {}", step.tick_next);
        
        // Cross the tick and get liquidity net change
        let mut liquidity_net = next_initialized_tick.cross(
            if zero_for_one {
                state.fee_growth_global_x64
            } else {
                pool_state.fee_growth_global_0_x64
            },
            if zero_for_one {
                pool_state.fee_growth_global_1_x64
            } else {
                state.fee_growth_global_x64
            },
            &updated_reward_infos,
        );
        
        // Update tick state in tick array
        tick_array_current.update_tick_state(
            next_initialized_tick.tick,
            pool_state.tick_spacing.into(),
            *next_initialized_tick,
        )?;
        
        // Update pool liquidity based on direction
        if zero_for_one {
            liquidity_net = liquidity_net.neg();
        }
        state.liquidity = liquidity_math::add_delta(state.liquidity, liquidity_net)?;
    }
    
    // Update current tick
    state.tick = if zero_for_one {
        step.tick_next - 1
    } else {
        step.tick_next
    };
}



1.2）代码：cross的时候做什么事情？
Tick State Cross Function
The cross function in TickState handles the actual tick transition:
pub fn cross(
    &mut self,
    fee_growth_global_0_x64: u128,
    fee_growth_global_1_x64: u128,
    reward_infos: &[RewardInfo; REWARD_NUM],
) -> i128 {
    // Update fee growth outside values
    self.fee_growth_outside_0_x64 = fee_growth_global_0_x64
        .checked_sub(self.fee_growth_outside_0_x64)
        .unwrap();
    self.fee_growth_outside_1_x64 = fee_growth_global_1_x64
        .checked_sub(self.fee_growth_outside_1_x64)
        .unwrap();
    
    // Update reward growth outside values
    for i in 0..REWARD_NUM {
        if !reward_infos[i].initialized() {
            continue;
        }
        self.reward_growths_outside_x64[i] = reward_infos[i]
            .reward_growth_global_x64
            .checked_sub(self.reward_growths_outside_x64[i])
            .unwrap();
    }
    
    // Return the liquidity net change
    self.liquidity_net
}


1.3 Liquidity Updates During Tick Crossings
The key insight is that liquidity changes when crossing ticks:

// When crossing a tick, update pool liquidity
if step.initialized {
    let mut liquidity_net = next_initialized_tick.cross(...);
    
    // For zero_for_one swaps, negate the liquidity net
    if zero_for_one {
        liquidity_net = liquidity_net.neg();
    }
    
    // Add the liquidity delta to current pool liquidity
    state.liquidity = liquidity_math::add_delta(state.liquidity, liquidity_net)?;
}

