目标：
1. 掌握compute_swap_step函数的作用
2. 掌握其核心模块及流程

内容：
1. 作用
This function computes one step of a swap operation, determining:
    How much input is consumed
    How much output is generated
    What the new price will be
    How much fee is charged

2. 核心模块
1) Single Step Calculation
The swap process executes tick-by-tick, and this function handles one tick boundary at a time:
let swap_step = swap_math::compute_swap_step(
    state.sqrt_price_x64,        // Current price
    target_price,                // Target price (next tick or user limit)
    state.liquidity,             // Current liquidity
    state.amount_specified_remaining, // Remaining input
    fee,                         // Fee rate
    is_base_input,               // Input type
    zero_for_one,                // Swap direction
    1,                           // Step size
).unwrap();

2) Two Input Modes
Exact Input Mode (is_base_input = true)

if is_base_input {
    // User specifies exact input amount
    let amount_remaining_less_fee = (amount_remaining as u64)
        .mul_div_floor(
            (FEE_RATE_DENOMINATOR_VALUE - fee_rate).into(),
            u64::from(FEE_RATE_DENOMINATOR_VALUE),
        )
        .unwrap();
}
What it does:
    User provides: Exact amount of input tokens
    Function calculates: How much output they'll receive
    Fee handling: Deducts fees from input before calculation

Exact Output Mode (is_base_input = false)
} else {
    // User specifies exact output amount
    let amount_out = calculate_amount_in_range(
        sqrt_price_current_x64,
        sqrt_price_target_x64,
        liquidity,
        zero_for_one,
        is_base_input,
        block_timestamp,
    )?;
}
What it does:
    User provides: Exact amount of output tokens desired
    Function calculates: How much input is needed
    Fee handling: Calculates fees on top of required input


3) Price Movement Calculation 
Target Price Reached  【TODO: target price啥意思？】

swap_step.sqrt_price_next_x64 = if amount_in.is_some() && amount_remaining_less_fee >= swap_step.amount_in {
    sqrt_price_target_x64  // Move to target price
} else {
    // Calculate new price based on available input
    sqrt_price_math::get_next_sqrt_price_from_input(
        sqrt_price_current_x64,
        liquidity,
        amount_remaining_less_fee,
        zero_for_one,
    )
};
Two scenarios:
    Full step: Enough input to reach target price
    Partial step: Input exhausted before reaching target

4） Amount Calculation Based on Direction
Zero-for-One (Token0 → Token1)
if zero_for_one {
    swap_step.amount_in = liquidity_math::get_delta_amount_0_unsigned(
        swap_step.sqrt_price_next_x64,
        sqrt_price_current_x64,
        liquidity,
        true,
    )?;
    swap_step.amount_out = liquidity_math::get_delta_amount_1_unsigned(
        swap_step.sqrt_price_next_x64,
        sqrt_price_current_x64,
        liquidity,
        false,
    )?;
}
Formula: Uses liquidity math to calculate exact amounts based on price change

One-for-Zero (Token1 → Token0)
} else {
    swap_step.amount_in = liquidity_math::get_delta_amount_1_unsigned(
        sqrt_price_current_x64,
        swap_step.sqrt_price_next_x64,
        liquidity,
        true,
    )?;
    swap_step.amount_out = liquidity_math::get_delta_amount_0_unsigned(
        sqrt_price_current_x64,
        swap_step.sqrt_price_next_x64,
        liquidity,
        false,
    )?;
}


5） Fee Calculation
Two Fee Scenarios
swap_step.fee_amount = if is_base_input && swap_step.sqrt_price_next_x64 != sqrt_price_target_x64 {
    // Didn't reach target - remaining input becomes fee
    u64::from(amount_remaining).checked_sub(swap_step.amount_in).unwrap()
} else {
    // Reached target - calculate fee as percentage
    swap_step.amount_in.mul_div_ceil(
        fee_rate.into(),
        (FEE_RATE_DENOMINATOR_VALUE - fee_rate).into(),
    ).unwrap()
};
Fee logic:
    Target not reached: Remaining input becomes fee (dust collection)
    Target reached: Standard percentage-based fee

