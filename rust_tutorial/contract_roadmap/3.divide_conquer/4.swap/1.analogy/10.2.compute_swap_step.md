目标：
1. 理解compute_swap_step的作用


内容：
1. 作用
swap_step的原因是，用户在当前pool tickprice对应的流动性下，添加的数量，可能超过了维持当前pool流动性所需的实际输入量，所以只能消耗部分，剩下的输入量会随着价格的移动，被其它的tick消耗掉。 

问题： 在计算实际所需消耗量的时候，哪些是变化的【用户提供导致的】，哪些是不变的？

通过查看代码发现，它计算的是当前tick到计算方向上的下一个tick的所需的实际amountin，在这个移动过程中，liquidity没有发生变化，价格发生了变化，储备量发生了变化。 



1.1 SwapStep结构体及作用
/// Result of a swap step
#[derive(Default, Debug)]
pub struct SwapStep {
    /// The price after swapping the amount in/out, not to exceed the price target
    pub sqrt_price_next_x64: u128,
    pub amount_in: u64,
    pub amount_out: u64,
    pub fee_amount: u64,
}

它作为 compute swap step 方法的 返回值，记录了当前swapstep操作中的 amount in , amount out, 以及操作完之后的价格。

1.2 代码

初始化结构体：
    let mut swap_step = SwapStep::default();

计算当前liquidity ，price range下所需的delta amount_in的数量，也就是当前swap step的amount in的实际消耗量：
  let amount_in = calculate_amount_in_range(
            sqrt_price_current_x64,
            sqrt_price_target_x64,
            liquidity,
            zero_for_one,
            is_base_input,
            block_timestamp,
        )?;
    if amount_in.is_some() {
            swap_step.amount_in = amount_in.unwrap();
        }
然后将其赋值到 swap_step中。

获取当前liquidity和sqrt_price_current_x64及方向下zero_for_one对应的下一个 sqrt_price_next_x64. 
swap_step.sqrt_price_next_x64 =
            if amount_in.is_some() && amount_remaining_less_fee >= swap_step.amount_in {
                sqrt_price_target_x64
            } else {
                sqrt_price_math::get_next_sqrt_price_from_input(
                    sqrt_price_current_x64,
                    liquidity,
                    amount_remaining_less_fee,
                    zero_for_one,
                )
            };
这表示当前swap step下，经过swap后的价格变化。


继续：用max变量记录经过swap后的sqrt price值
    // whether we reached the max possible price for the given ticks
    let max = sqrt_price_target_x64 == swap_step.sqrt_price_next_x64;

TODO: ???
    // get the input / output amounts when target price is not reached
    if zero_for_one {
        // if max is reached for exact input case, entire amount_in is needed
        if !(max && is_base_input) {
            swap_step.amount_in = liquidity_math::get_delta_amount_0_unsigned(
                swap_step.sqrt_price_next_x64,
                sqrt_price_current_x64,
                liquidity,
                true,
            )?
        };
        // if max is reached for exact output case, entire amount_out is needed
        if !(max && !is_base_input) {
            swap_step.amount_out = liquidity_math::get_delta_amount_1_unsigned(
                swap_step.sqrt_price_next_x64,
                sqrt_price_current_x64,
                liquidity,
                false,
            )?;
        };
    } else {
        if !(max && is_base_input) {
            swap_step.amount_in = liquidity_math::get_delta_amount_1_unsigned(
                sqrt_price_current_x64,
                swap_step.sqrt_price_next_x64,
                liquidity,
                true,
            )?
        };
        if !(max && !is_base_input) {
            swap_step.amount_out = liquidity_math::get_delta_amount_0_unsigned(
                sqrt_price_current_x64,
                swap_step.sqrt_price_next_x64,
                liquidity,
                false,
            )?
        };
    }


//TODO: ???
    // For exact output case, cap the output amount to not exceed the remaining output amount
    if !is_base_input && swap_step.amount_out > amount_remaining {
        swap_step.amount_out = amount_remaining;
    }

//TODO: ???
    swap_step.fee_amount =
        if is_base_input && swap_step.sqrt_price_next_x64 != sqrt_price_target_x64 {
            // we didn't reach the target, so take the remainder of the maximum input as fee
            // swap dust is granted as fee
            u64::from(amount_remaining)
                .checked_sub(swap_step.amount_in)
                .unwrap()
        } else {
            // take pip percentage as fee
            swap_step
                .amount_in
                .mul_div_ceil(
                    fee_rate.into(),
                    (FEE_RATE_DENOMINATOR_VALUE - fee_rate).into(),
                )
                .unwrap()
        };