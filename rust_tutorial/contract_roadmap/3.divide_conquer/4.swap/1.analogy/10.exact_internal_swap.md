目标：
1. 掌握swap合约指令的执行过程

内容：
1. 过程
continue swapping as long as we haven't used the entire input/output and haven't reached the price 
limit 

1.1 核心代码
 while state.amount_specified_remaining != 0 && state.sqrt_price_x64 != sqrt_price_limit_x64{
    ...
 }

只要input/output还没有消耗完，这里input/output是用 swap state中的amount_specified_remaining 来表示
，只要它等于0，就表示消耗完。 
while state.amount_specified_remaining != 0 

如何swap state 的 sqrt_price_x64 等于 sqrt_price_limit_x64，就表示已经到达了下一个tick的边界，需要进行跨tick操作了。 也就是说swap state 的 sqrt_price_x64在这个过程中，是会变化的[TODO: 验证]。 


接下来我们逐步看代码理解这个执行过程：
        let mut step = StepComputations::default();
        step.sqrt_price_start_x64 = state.sqrt_price_x64;
初始化StepComputations结构体，然后给step赋值，记录当前step的pool price.


继续：获取当前tick所在的tickArray的下一个initialized tick
let mut next_initialized_tick = if let Some(tick_state) = tick_array_current
            .next_initialized_tick(state.tick, pool_state.tick_spacing, zero_for_one)?
        {
            Box::new(*tick_state)
        } else {
            if !is_match_pool_current_tick_array {
                is_match_pool_current_tick_array = true;
                Box::new(*tick_array_current.first_initialized_tick(zero_for_one)?)
            } else {
                Box::new(TickState::default())
            }
        };
其中next_initialized_tick 参考 rust_tutorial/contract_roadmap/3.divide_conquer/3.position/2.experiments/26.get_next_initialized_tick


继续，如果当前tickArray中没有找到下一个initialized tick，则通过tickArray_bitmap_extension获取下一个tickArray,然后获取这个新的tickArray的的第一个初始化的tick:
        if !next_initialized_tick.is_initialized() {
            let next_initialized_tickarray_index = pool_state
                .next_initialized_tick_array_start_index(
                    &tickarray_bitmap_extension,
                    current_vaild_tick_array_start_index,
                    zero_for_one,
                )?;
            if next_initialized_tickarray_index.is_none() {
                return err!(ErrorCode::LiquidityInsufficient);
            }

            while tick_array_current.start_tick_index != next_initialized_tickarray_index.unwrap() {
                tick_array_current = tick_array_states
                    .pop_front()
                    .ok_or(ErrorCode::NotEnoughTickArrayAccount)?;
                // check the tick_array account is owned by the pool
                require_keys_eq!(tick_array_current.pool_id, pool_state.key());
            }
            current_vaild_tick_array_start_index = next_initialized_tickarray_index.unwrap();

            let first_initialized_tick = tick_array_current.first_initialized_tick(zero_for_one)?;
            next_initialized_tick = Box::new(*first_initialized_tick);
        }


继续往下阅读：  记录下一个initialized的tick及initialized状态到step中
step.tick_next = next_initialized_tick.tick;
step.initialized = next_initialized_tick.is_initialized();


继续： 更新step.tick_next值
  if step.tick_next < tick_math::MIN_TICK {
            step.tick_next = tick_math::MIN_TICK;
        } else if step.tick_next > tick_math::MAX_TICK {
            step.tick_next = tick_math::MAX_TICK;
 }


继续：记录step的下一个 tick_next 对应的 sqrt_price_next_x64.
        step.sqrt_price_next_x64 = tick_math::get_sqrt_price_at_tick(step.tick_next)?;


下面是一个关键点：target price的定义 ，记录 的是下一个initialized对应的sqrt_price_next_x64.
      let target_price = if (zero_for_one && step.sqrt_price_next_x64 < sqrt_price_limit_x64)
            || (!zero_for_one && step.sqrt_price_next_x64 > sqrt_price_limit_x64)
        {
            sqrt_price_limit_x64
        } else {
            step.sqrt_price_next_x64
        };


继续：swap_math::compute_swap_step 
    let swap_step = swap_math::compute_swap_step(
            step.sqrt_price_start_x64,
            target_price,
            state.liquidity,
            state.amount_specified_remaining,
            amm_config.trade_fee_rate,
            is_base_input,
            zero_for_one,
            block_timestamp,
        )?;

继续：更新 swap_state的当前 price, 计算    
        state.sqrt_price_x64 = swap_step.sqrt_price_next_x64;  // current sqrt(price)
        step.amount_in = swap_step.amount_in;         // how much is being swapped in in this step
        step.amount_out = swap_step.amount_out;      // how much is being swapped out
        step.fee_amount = swap_step.fee_amount;


继续：更新amount_specified_remaining剩余数量，用它减去上一个swap step中 amount in的消耗量。
  state.amount_specified_remaining = state
                .amount_specified_remaining
                .checked_sub(step.amount_in + step.fee_amount)
                .unwrap();
            state.amount_calculated = state
                .amount_calculated
                .checked_add(step.amount_out)
                .unwrap();

继续： 如果当前swap state的sqrt_price_x64 经过swap后，到达了sqrt_price_next_x64（target price）,
如果当前next_tick 已经initialized , 执行tick transition.
  // if the tick is initialized, run the tick transition
            if step.initialized {
                #[cfg(feature = "enable-log")]
                msg!("loading next tick {}", step.tick_next);

                let mut liquidity_net = next_initialized_tick.cross(
                    if zero_for_one {
                        state.fee_growth_global_x64
                    } else {
                        pool_state.fee_growth_global_0_x64
                    },
                    if zero_for_one {
                        pool_state.fee_growth_global_1_x64
                    } else {
                        state.fee_growth_global_x64
                    },
                    &updated_reward_infos,
                );
                // update tick_state to tick_array account
                tick_array_current.update_tick_state(
                    next_initialized_tick.tick,
                    pool_state.tick_spacing.into(),
                    *next_initialized_tick,
                )?;

                if zero_for_one {
                    liquidity_net = liquidity_net.neg();
                }
                state.liquidity = liquidity_math::add_delta(state.liquidity, liquidity_net)?;
            }

            state.tick = if zero_for_one {
                step.tick_next - 1
            } else {
                step.tick_next
            };


我们继续重点看一下cross方法： 它返回了下一个initialized的 liquidity_net. 

继续： 更新next_initialized_tick 到tickArray的ticks数组中
     // update tick_state to tick_array account
                tick_array_current.update_tick_state(
                    next_initialized_tick.tick,
                    pool_state.tick_spacing.into(),
                    *next_initialized_tick,
                )?;


继续：更新当前swapstate在price range内的流动性，如果方向是zero_for_one, 表示tick向左，需要减去流动性；
如果向右，表示添加流动性。[TODO: 实验验证]

if zero_for_one {
    liquidity_net = liquidity_net.neg();
}
state.liquidity = liquidity_math::add_delta(state.liquidity, liquidity_net)?;


继续： 如果发生了cross tick行为，需要继续更新tick状态。
    // update tick
    if state.tick != pool_state.tick_current {
        // update the previous tick to the observation
        observation_state.update(block_timestamp, pool_state.tick_current);
        pool_state.tick_current = state.tick;
    }

然后：更新池子价格
    pool_state.sqrt_price_x64 = state.sqrt_price_x64;

继续：更新池子中的流动性：
    if liquidity_start != state.liquidity {
        pool_state.liquidity = state.liquidity;
    }