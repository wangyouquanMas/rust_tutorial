1. 创建swap交易

1）输入: ./target/release/client swap 5Kar97KcLTHFP7iMMbRgB74zXHVL43yEmURwD3Z6RvdT C1fFxBc2oeWvBW3PA4bFQ67jGUqzHHyDKytukWxpEMr4 --base-in 500000000


2) 输出： 
Starting...
tick_index: 443636
tick_spacing: 60
ticks_in_array: 3600
start: 123
start: 123
tick_index: -443636
tick_spacing: 60
ticks_in_array: 3600
start: -123
start: -124
tick_index: -69082
tick_spacing: 60
ticks_in_array: 3600
start: -19
start: -20
tick_index: -72000
tick_spacing: 60
ticks_in_array: 3600
start: -20
start: -20
tick_index: -443636
tick_spacing: 60
ticks_in_array: 3600
start: -123
start: -124
tick_index: 443636
tick_spacing: 60
ticks_in_array: 3600
start: 123
start: 123
tick_index: 443636
tick_spacing: 60
ticks_in_array: 3600
start: 123
start: 123
tick_index: -443636
tick_spacing: 60
ticks_in_array: 3600
start: -123
start: -124
tick_index: -69082
tick_spacing: 60
ticks_in_array: 3600
start: -19
start: -20
tick_index: -69082
tick_spacing: 60
ticks_in_array: 3600
start: -19
start: -20
tick: -71340
abs_tick: 71340
calculate delta amount0
sqrt_ratio_a_x64: 521037230575395660
sqrt_ratio_b_x64: 583337266871351552
liquidity: 363379595
round_up: true
get_delta_amount_0_unsigned result: 1373978951
calculate delta amount0
sqrt_ratio_a_x64: 559083387458920476
sqrt_ratio_b_x64: 583337266871351552
liquidity: 363379595
round_up: true
get_delta_amount_0_unsigned result: 498500000
sqrt_ratio_a_x64: 559083387458920476
sqrt_ratio_b_x64: 583337266871351552
liquidity: 363379595
round_up: false
U256::from(liquidity): 363379595
U256::from(sqrt_ratio_b_x64 - sqrt_ratio_a_x64): 24253879412431076
U256::from(fixed_point_64::Q64): 18446744073709551616
result: 477773
tick: -69930
abs_tick: 69930
tick_array_start_index:[-72000]
amount:500000000, other_amount_threshold:477773
QxKi4H8wmWdcqV9D7Crth2b9npLkdigku3bSPXn5YUonc7WiJxNrQ6VG1bHqUxJoWdJw4e7kCZAybNFMKYXg8UL


3) 执行流程

step1: swap指令输入参数及账户
参数
base_in:true
simulate:false
amount:5000000
limit_price:None
账户
input_token:5Kar97KcLTHFP7iMMbRgB74zXHVL43yEmURwD3Z6RvdT
output_token:C1fFxBc2oeWvBW3PA4bFQ67jGUqzHHyDKytukWxpEMr4
amm_config_key:AENbU71VcXS6eCaegq4zGJtJCE7xyRLoiE7A3kvibF89
pool_id_account:9n3gbTfd1U35dPHV5xBFQDLz5qhQzRcqksXsfe9cfUWb
tickarray_bitmap_extension:HnXCbbydieUbFjyCjuGCTNi1ZBGboBXWMUSxmUuz2W6k [TODO: 解析来数据结构及作用]

step2: 获取账户状态数据
1） let user_input_state =
                StateWithExtensions::<Account>::unpack(&user_input_account.as_ref().unwrap().data)
                    .unwrap()
data: [Token mint]
1. user_input_state.base.mint
应用场景： let zero_for_one = user_input_state.base.mint == pool_state.token_mint_0
                && user_output_state.base.mint == pool_state.token_mint_1;


2） let user_output_state =
                StateWithExtensions::<Account>::unpack(&user_output_account.as_ref().unwrap().data)
                    .unwrap();
data: [Token mint]
1. user_output_state.base.mint
应用场景： let zero_for_one = user_input_state.base.mint == pool_state.token_mint_0
                && user_output_state.base.mint == pool_state.token_mint_1;


3） let amm_config_state = deserialize_anchor_account::<raydium_amm_v3::states::AmmConfig>(
                amm_config_account.as_ref().unwrap(),
            )?;
应用场景：
let (mut other_amount_threshold, mut tick_array_indexs) =
                utils::get_out_put_amount_and_remaining_accounts(
                    amount,
                    sqrt_price_limit_x64,
                    zero_for_one,
                    base_in,
                    &amm_config_state,
                    &pool_state,
                    &tickarray_bitmap_extension,
                    &mut tick_arrays,
                )
                .unwrap();
println!("amount:{}, other_amount_threshold:{}",
                amount, other_amount_threshold
            );



4） let pool_state = deserialize_anchor_account::<raydium_amm_v3::states::PoolState>(
                pool_account.as_ref().unwrap(),
            )?;
应用场景：
a) let zero_for_one = user_input_state.base.mint == pool_state.token_mint_0
                && user_output_state.base.mint == pool_state.token_mint_1;
b)   //load tick_arrays
   let mut tick_arrays = load_cur_and_next_five_tick_array(
                &rpc_client,
                &pool_config,
                &pool_state,
                &tickarray_bitmap_extension,
                zero_for_one,
            );
c)  let mut sqrt_price_limit_x64 = None;
            if limit_price.is_some() {
                let sqrt_price_x64 = price_to_sqrt_price_x64(
                    limit_price.unwrap(),
                    pool_state.mint_decimals_0,
                    pool_state.mint_decimals_1,
                );
                sqrt_price_limit_x64 = Some(sqrt_price_x64);
            }
d) let (mut other_amount_threshold, mut tick_array_indexs) =
                utils::get_out_put_amount_and_remaining_accounts(
                    amount,
                    sqrt_price_limit_x64,
                    zero_for_one,
                    base_in,
                    &amm_config_state,
                    &pool_state,
                    &tickarray_bitmap_extension,
                    &mut tick_arrays,
                )
                .unwrap();
            println!(
                "amount:{}, other_amount_threshold:{}",
                amount, other_amount_threshold
            );
e) let swap_instr = swap_instr(
                &pool_config.clone(),
                pool_state.amm_config,
                pool_config.pool_id_account.unwrap(),
                if zero_for_one {
                    pool_state.token_vault_0
                } else {
                    pool_state.token_vault_1
                },
                if zero_for_one {
                    pool_state.token_vault_1
                } else {
                    pool_state.token_vault_0
                },
                pool_state.observation_key,
                input_token,
                output_token,
                current_or_next_tick_array_key,
                remaining_accounts,
                amount,
                other_amount_threshold,
                sqrt_price_limit_x64,
                base_in,
            )
            .unwrap();
            instructions.extend(swap_instr);

5） let tickarray_bitmap_extension =
                deserialize_anchor_account::<raydium_amm_v3::states::TickArrayBitmapExtension>(
                    tickarray_bitmap_extension_account.as_ref().unwrap(),
                )?;
应用场景：
a) // load tick_arrays
            let mut tick_arrays = load_cur_and_next_five_tick_array(
                &rpc_client,
                &pool_config,
                &pool_state,
                &tickarray_bitmap_extension,
                zero_for_one,
            );
b) let (mut other_amount_threshold, mut tick_array_indexs) =
                utils::get_out_put_amount_and_remaining_accounts(
                    amount,
                    sqrt_price_limit_x64,
                    zero_for_one,
                    base_in,
                    &amm_config_state,
                    &pool_state,
                    &tickarray_bitmap_extension,
                    &mut tick_arrays,
                )
                .unwrap();
            println!(
                "amount:{}, other_amount_threshold:{}",
                amount, other_amount_threshold
            );
c) let mut remaining_accounts = Vec::new();
            remaining_accounts.push(AccountMeta::new_readonly(
                pool_config.tickarray_bitmap_extension.unwrap(),
                false,
            ));


Step3) 计算兑换方向
  let zero_for_one = user_input_state.base.mint == pool_state.token_mint_0
                && user_output_state.base.mint == pool_state.token_mint_1;
token_mint_0 -> token_mint_1


Step4) Load tick arrays 
a) 获取第一个已初始化的 tick array 
let (_, mut current_vaild_tick_array_start_index) = pool_state
        .get_first_initialized_tick_array(&Some(*tickarray_bitmap_extension), zero_for_one)
        .unwrap();









4) Critical Role of Ticks in the Swap Process
a) Liquidity Distribution
Tick represent price poitns where liquidity is concentrated
Each tick has a liquidity_gross value indicating total liquidity at that price
Tick arrays group multiple ticks together for efficient storage and access  

b) Price Movement Calculation
Swaps move the current price from one tick to another
Tick spacing determines the granularity of price changes  [TODO: 给个例子]
The tick_current in pool state tracks the current price position. 

c) Liquidity Access Pattern
// Load current and next 5 tick arrays in the swap direction
let mut tick_arrays = load_cur_and_next_five_tick_array(
    &rpc_client,
    &pool_config,
    &pool_state,
    &tickarray_bitmap_extension,
    zero_for_one,  // Direction determines which tick arrays to load
);

d) Slippage and Price Impact
Ticks with higher liquidity provide better prices and lower slippage
Ticks with lower liquidity cause higher slippage and price impact
The system calculates other_amount_threshold based on available liquidity across tick ranges. 

e) Tick Array Management
Bitmap extension tracks which tick arrays are initialized
Tick array indices are calculated based on the swap direction and current position
Remaining accounts include all tick arrays that might be modified during the swap

f) Price Range Boundaries
Tick lower/upper define the price range for liquidity positions
Swaps can only access liquidity within initialized tick arrays
Tick array start indices are calculated using :
raydium_amm_v3::states::TickArrayState::get_array_start_index(
    tick_index,
    tick_spacing
)




