Status: Confirmed that tick_array_lower/tick_array_upper are the PDAs backing TickArrayState for the arrays that contain your lower/upper ticks; they’re passed unchecked and then loaded as TickArrayState inside the instruction.
They are PDAs of TickArrayState keyed by ("tick_array", pool_id, start_tick_index).
Lower/upper refer to the arrays that contain the position’s lower/upper ticks; they can be the same PDA if both ticks share the same start index.



问题1： tick_array_lower/upper PDA账户的创建方式  
    pub const TICK_ARRAY_SEED: &str = "tick_array";

    let (tick_array_lower, __bump) = Pubkey::find_program_address(
        &[
            TICK_ARRAY_SEED.as_bytes(),
            pool_account_key.to_bytes().as_ref(),
            &tick_array_lower_start_index.to_be_bytes(),
        ],
        &program.id(),
    );

问题2： tick array的数据结构？ 它里面记录了哪些数据？ 

#[account(zero_copy(unsafe))]
#[repr(C, packed)]
pub struct TickArrayState {
    pub pool_id: Pubkey,
    pub start_tick_index: i32,
    pub ticks: [TickState; TICK_ARRAY_SIZE_USIZE],
    pub initialized_tick_count: u8,
    // account update recent epoch
    pub recent_epoch: u64,
    // Unused bytes for future upgrades.
    pub padding: [u8; 107],
}

包含信息有：
1）pool_id 
2) start_tick_index  [TODO:]
3) ticks 
4) recent_epoch  [TODO:]
5) padding  [TODO:]
 
pub struct TickState {
    pub tick: i32,
    /// Amount of net liquidity added (subtracted) when tick is crossed from left to right (right to left)
    pub liquidity_net: i128,
    /// The total position liquidity that references this tick
    pub liquidity_gross: u128,

    /// Fee growth per unit of liquidity on the _other_ side of this tick (relative to the current tick)
    /// only has relative meaning, not absolute — the value depends on when the tick is initialized
    pub fee_growth_outside_0_x64: u128,
    pub fee_growth_outside_1_x64: u128,

    // Reward growth per unit of liquidity like fee, array of Q64.64
    pub reward_growths_outside_x64: [u128; REWARD_NUM],
    // Unused bytes for future upgrades.
    pub padding: [u32; 13],
}

ticks中记录了什么信息？
1）tick   [TODO:]
    It is the absolute tick index that this TickState represents in the global tick grid.

2) liquidity net  [TODO:]
3) liquidity_gross  [TODO:]
4) fee_growth_outside_0_x64  [TODO:]
5) fee_growth_outside_1_x64  [TODO:]
6) reward_growths_outside_x64  [TODO:]
7) padding  [TODO:]


问题2： 这个tick array里的数据，是什么时候怎么塞进去的？ 

1） 先创建账户，分配空间并初始化
A tick array is a PDA derived from seeds:"tick_array",pool_id,start_tick_index. If the account doesn't exist,it's created and initialized. 

let tick_array_lower_loader = TickArrayState::get_or_create_tick_array(
            payer.to_account_info(),
            tick_array_lower_loader.to_account_info(),
            system_program.to_account_info(),
            &pool_state_loader,
            tick_array_lower_start_index,
            pool_state.tick_spacing,
        )?;

/// Load a TickArrayState of type AccountLoader from tickarray account info, if tickarray account does not exist, then create it.
pub fn get_or_create_tick_array<'info>(
        payer: AccountInfo<'info>,
        tick_array_account_info: AccountInfo<'info>,
        system_program: AccountInfo<'info>,
        pool_state_loader: &AccountLoader<'info, PoolState>,
        tick_array_start_index: i32,
        tick_spacing: u16,
    ) -> Result<AccountLoad<'info, TickArrayState>> {
        require!(
            TickArrayState::check_is_valid_start_index(tick_array_start_index, tick_spacing),
            ErrorCode::InvalidTickIndex
        );

        let tick_array_state = if tick_array_account_info.owner == &system_program::ID {
            let (expect_pda_address, bump) = Pubkey::find_program_address(
                &[
                    TICK_ARRAY_SEED.as_bytes(),
                    pool_state_loader.key().as_ref(),
                    &tick_array_start_index.to_be_bytes(),
                ],
                &crate::id(),
            );
            require_keys_eq!(expect_pda_address, tick_array_account_info.key());
            create_or_allocate_account(
                &crate::id(),
                payer,
                system_program,
                tick_array_account_info.clone(),
                &[
                    TICK_ARRAY_SEED.as_bytes(),
                    pool_state_loader.key().as_ref(),
                    &tick_array_start_index.to_be_bytes(),
                    &[bump],
                ],
                TickArrayState::LEN,
            )?;
            let tick_array_state_loader = AccountLoad::<TickArrayState>::try_from_unchecked(
                &crate::id(),
                &tick_array_account_info,
            )?;
            {
                let mut tick_array_account = tick_array_state_loader.load_init()?;
                tick_array_account.initialize(
                    tick_array_start_index,
                    tick_spacing,
                    pool_state_loader.key(),
                )?;
            }
            tick_array_state_loader
        } else {
            AccountLoad::<TickArrayState>::try_from(&tick_array_account_info)?
        };
        Ok(tick_array_state)
    }


//TODO: initialize sets metadata and recent epoch 
    pub fn initialize(
        &mut self,
        start_index: i32,
        tick_spacing: u16,
        pool_key: Pubkey,
    ) -> Result<()> {
        TickArrayState::check_is_valid_start_index(start_index, tick_spacing);
        self.start_tick_index = start_index;
        self.pool_id = pool_key;
        self.recent_epoch = get_recent_epoch()?;
        Ok(())
    }




//TODO: On first position open: the lower/upper ticks are written into the array if empty.
tick_array_lower_loader
    .load_mut()?
    .get_tick_state_mut(tick_lower_index, pool_state.tick_spacing)?
    .tick = tick_lower_index;
tick_array_upper_loader
    .load_mut()?
    .get_tick_state_mut(tick_upper_index, pool_state.tick_spacing)?
    .tick = tick_upper_index;



//命令：./target/release/client open-position 0.00015 0.00017 --is-base-0 100
//输出：  ~
//TODO: get_tick_state_mut 
pub fn get_tick_state_mut(
        &mut self,
        tick_index: i32,
        tick_spacing: u16,
    ) -> Result<&mut TickState> {
        //> Program log: get_tick_state_mut, tick_index: -157140, tick_spacing: 60
        msg!("get_tick_state_mut, tick_index: {}, tick_spacing: {}", tick_index, tick_spacing);

        let offset_in_array = self.get_tick_offset_in_array(tick_index, tick_spacing)?;

        //> Program log: get_tick_state_mut, offset_in_array: 21
        msg!("get_tick_state_mut, offset_in_array: {}", offset_in_array);

        //> Program log: get_tick_state_mut, self.ticks[offset_in_array]: TickState { tick: 0, liquidity_net: 0, liquidity_gross: 0, fee_growth_outside_0_x64: 0, fee_growth_outside_1_x64: 0, reward_growths_outside_x64: [0, 0, 0], padding: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] }
        msg!("get_tick_state_mut, self.ticks[offset_in_array]: {:?}", self.ticks[offset_in_array]);


        // > Program log: get_tick_state_mut, tick_index: -155940, tick_spacing: 60
        // > Program log: get_tick_state_mut, offset_in_array: 41
        // > Program log: get_tick_state_mut, self.ticks[offset_in_array]: TickState { tick: 0, liquidity_net: 0, liquidity_gross: 0, fee_growth_outside_0_x64: 0, fee_growth_outside_1_x64: 0, reward_growths_outside_x64: [0, 0, 0], padding: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] }

        Ok(&mut self.ticks[offset_in_array])
    }



//TODO: After modifying liquidity (open/increase/decrease): the in-memory TickState changes (liquidity/fee/rewards) are persisted back into the array.
1) Open positions
tick_array_lower_loader.load_mut()?.update_tick_state(
    tick_lower_index, pool_state.tick_spacing, tick_lower_state,
)?;
tick_array_upper_loader.load_mut()?.update_tick_state(
    tick_upper_index, pool_state.tick_spacing, tick_upper_state,
)?;

2) decrease liquidity 
tick_array_lower_loader.load_mut()?.update_tick_state(
    protocol_position.tick_lower_index, pool_state.tick_spacing, tick_lower_state,
)?;
tick_array_upper_loader.load_mut()?.update_tick_state(
    protocol_position.tick_upper_index, pool_state.tick_spacing, tick_upper_state,
)?;

//TODO: During swaps when crossing a tick: the crossed tick is updated then stored back.
// update tick_state to tick_array account
tick_array_current.update_tick_state(
    next_initialized_tick.tick,
    pool_state.tick_spacing.into(),
    *next_initialized_tick,
)?;


//TODO: 什么时候更新state？ 更新什么状态？
pub fn update_tick_state(
        &mut self,
        tick_index: i32,
        tick_spacing: u16,
        tick_state: TickState,
    ) -> Result<()> {
        let offset_in_array = self.get_tick_offset_in_array(tick_index, tick_spacing)?;
        self.ticks[offset_in_array] = tick_state;
        self.recent_epoch = get_recent_epoch()?;
        Ok(())
    }


Note: the tick array account itself is created/initialized lazily via get_or_create_tick_array; ticks inside start zeroed and are only stored/updated when operations touch them.

