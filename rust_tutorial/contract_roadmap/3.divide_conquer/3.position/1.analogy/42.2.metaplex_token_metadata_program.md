目标:
1. 理解Metaplex Token Metadata定义
2. 掌握Metaplex TOken Metadata用法

内容：
1. 定义


2. 用法
When creating an NFT, the Token Metadata program creates an onchain metadata account using a Program Derived Address(PDA) with the token mint as a seed.
This allows the metadata account for ny NFT tobe located determinstically using the address of the token mint. 

The onchain metadata contains a URI field that points to tan offchain .json file. 

2.1 The offchain metadata 
在JSON 文件中的 Offchain metadata 存储了 link ,该link指向NFT的media数据，包括：images, videos, 3D files,NFT可能会有的any traits 以及额外的metadata

示例： this example JSON file 
https://lsc6xffbdvalb5dvymf5gwjpeou7rr2btkoltutn5ij5irlpg3wa.arweave.net/XIXrlKEdQLD0dcML01kvI6n4x0GanLnSbeoT1EVvNuw

2.2 数据持久化存储在哪里？
Permanent data storage systems 比如 Arweave 经常被用于存储 NFT metadata的 offchain component。 


3. practice
在接下来的sections中，我们会cover metaplex-foundation/token-metadata的基础plugin with Umi to prepare assets, create NFTs, update NFTs, and associate an NFT with abroader collection. 对于metaplex-foundation/token-metadata的更多信息，参考：https://developers.metaplex.com/token-metadata

3.1. UMI instance 
Umi 是一个 framework，用于mkaing JS/TS clients for onchain programs, that was created by Metaplex. Umi可以创建JS/TS clients 为许多programs,但是在实践中，它最长被用来与 Token Metadata program沟通。 

Note Umi 相比于web3.js对许多概念有不同的实现，这些概念包括：Keypairs, PublicKeys, and Connectionis. 然而，也很容易convert from web3.js versions of these items to the Umi equivalents. 

3.2 Installation and setting up Umi
首先我们创建一个 Umi instance. 我们可以do this by either providing our own RPC endpoint, or use the public facing Solana endpoints provided by the clusterApiUrl method. 

import { createUmi } from "@metaplex-foundation/umi-bundle-defaults";
import { clusterApiUrl } from "@solana/web3.js";

const umi = createUmi(clusterApiUrl("devnet"));

Finally, we pass in the identity for our Umi instance(this is the keypair that will be used to sign transactions)and the plugins that we will use, in our case, this is the metaplex-foundation/mpl-token-metadata. 

import { mplTokenMetadata } from "@metaplex-foundation/mpl-token-metadata";
import { keypairIdentity } from "@metaplex-foundation/umi";
import { createUmi } from "@metaplex-foundation/umi-bundle-defaults";
import { getKeypairFromFile } from "@solana-developers/helpers";
import { promises as fs } from "fs";
import { clusterApiUrl } from "@solana/web3.js";

const umi = createUmi(clusterApiUrl("devnet"));

// load keypair from local file system
// See https://github.com/solana-developers/helpers?tab=readme-ov-file#get-a-keypair-from-a-keypair-file
const localKeypair = await getKeypairFromFile();

// convert to Umi compatible keypair
const umiKeypair = umi.eddsa.createKeypairFromSecretKey(localKeypair.secretKey);

// load the MPL metadata program plugin and assign a signer to our umi instance
umi.use(keypairIdentity(umiKeypair)).use(mplTokenMetadata());


3.3 Uploading assets 
Before creating an NFT, you must prepare and upload any assets you plan to associate with the NFT. While this doesn't have to be an image, most NFTs have an image associated with them.

Preparing and uploading an image involves converting the iamge to a buffer, converting the file to a generic file using the createGenericFile() function finally uploading it to the designated Storage Driver. 

The GenericFile type allows Umi to support different file variations despite the difference of browser files and local file system files i.e. those on your computer.

In action, uploading an image named random-image.png from your computer would take the following steps:

Reading the file using readFile into a buffer.

Creating a generic file type with the files MIME Type from the buffer and filePath.

Uploading file to designated storage provider.

let filePath = "random-image.png";

const buffer = await fs.readFile(filePath);
let file = createGenericFile(buffer, filePath, {
  // chose the correct file MIME type https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types
  contentType: "image/jpeg",
});
const [image] = await umi.uploader.upload([file]);
The function's return value will be the URI where the image was stored.


3.4 Upload metadata 
After uploading an image, it's time to upload the offchain JSON metadata using the uploadJson() method. This will return a URI where the JSON metadata is stored.

Remember, the offchain portion of the metadata includes things like the image URI as well as additional information like the name and description of the NFT. While you can technically include anything you'd like in this JSON object, in most cases, you should follow the NFT standard to ensure compatibility with wallets, programs, and applications.

To create the metadata, use the uploadJson() method provided by the SDK. This method accepts a metadata object and returns a URI that points to the uploaded metadata.

const uri = await umi.uploader.uploadJson({
  name,
  description,
  image,
});


3.5 Create the NFT
After uploading the NFT's metadata, you can finally create the NFT on the network. 
 The helper createNft method will create the mint account, token account, metadata account, and master edition account for you. 
 The data provided to this method will represent the onchain portion of the NFT metadata. 
 You can explore the SDK to see all the other input optionally supplied to this method.

 const { signature, result } = await createNft(umi, {
  mint,
  name: "My NFT",
  uri,
  updateAuthority: umi.identity.publicKey,
  sellerFeeBasisPoints: percentAmount(0),
}).sendAndConfirm(umi, { send: { commitment: "finalized" } });

The sendAndConfirm method is what takes care of signing our transaction and sending it. It also provides other options to set pre-flight checks and our desired commitment for the transaction, which defaults to confirmed if not provided.

This method returns an object containing the transaction signature and a result. The result object contains the outcome of our transaction. If successful, the err inside this will be set to null otherwise it'll contain the error for the failed transaction.

By default, the SDK sets the isMutable property to true, allowing for updates to be made to the NFT's metadata. However, you can choose to set isMutable to false, making the NFT's metadata immutable.