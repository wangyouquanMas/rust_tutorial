目标：
1. 掌握offset的计算方式



内容：
1. offset计算
Offset formula:
    First compute the array’s start for the given tick: start = get_array_start_index(tick_index, tick_spacing).
    Require it matches this array’s start: start == self.start_tick_index.
    Then offset = (tick_index - self.start_tick_index) / tick_spacing.
    Result is in [0, 59].


1.1 代码

    /// Get tick's offset in current tick array, tick must be include in tick array， otherwise throw an error
    fn get_tick_offset_in_array(self, tick_index: i32, tick_spacing: u16) -> Result<usize> {
        let start_tick_index = TickArrayState::get_array_start_index(tick_index, tick_spacing);
        require_eq!(
            start_tick_index,
            self.start_tick_index,
            ErrorCode::InvalidTickArray
        );
        let offset_in_array =
            ((tick_index - self.start_tick_index) / i32::from(tick_spacing)) as usize;
        Ok(offset_in_array)
    }

Example:
start_tick_index = -136800, tick_spacing = 60
tick = -136380 → offset = (-136380 - -136800)/60 = 420/60 = 7
tick = -135540 → offset = 1260/60 = 21


问题： what tick_index is in the above example ? 
It’s any integer tick on the global tick grid (the index of a price level), e.g., a position bound tick or the current price tick.
The function maps that tick to the start index of the 60-tick chunk (tick array) that contains it, using floor division (with correct handling for negatives). It does not require tick_index to be aligned to tick_spacing.
