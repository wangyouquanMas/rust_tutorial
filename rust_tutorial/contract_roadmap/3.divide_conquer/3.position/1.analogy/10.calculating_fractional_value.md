问题：
1. 如何表示小数的二进制？
In binary: The digit to the right of the decimal point (the binary point) represents fractions of 2.
The first digit after the binary point represents  1/2；
The second digit represents 1/4；
The third digit represents 1/8， and so on. 


1.1 How to Convert "0.1" from Binary to Decimal (10进制):

0.1 in binary means: 1*1/2 = 0.5 



2. 



# Simple Example of Calculating the Fractional Part of log₂

Let's work through a simple example to illustrate how the algorithm calculates the fractional part of log₂.

## Example: Calculate log₂(1.5)

We know that log₂(1.5) is between 0 and 1 (since 2⁰ = 1 < 1.5 < 2 = 2¹).
The exact value is approximately 0.585, but let's see how the algorithm computes this.

### Step 1: Setup

- Input value: x = 1.5
- Since 1 ≤ x < 2, it's already normalized
- Initial bit value: 0.5 (2⁻¹)
- Initial fractional result: 0

### Step 2: First Iteration (i = 1)

1. Square x: x² = 1.5² = 2.25
2. Is x² ≥ 2? Yes (2.25 > 2)
3. Add current bit to result: 0 + 0.5 = 0.5
4. Divide x² by 2: 2.25 ÷ 2 = 1.125
5. New x = 1.125

### Step 3: Second Iteration (i = 2)

1. Square x: x² = 1.125² = 1.265625
2. Is x² ≥ 2? No (1.265625 < 2)
3. Result remains: 0.5
4. x remains: 1.265625

### Step 4: Third Iteration (i = 3)

1. Square x: x² = 1.265625² = 1.6017913818359375
2. Is x² ≥ 2? No (1.6017913818359375 < 2)
3. Result remains: 0.5
4. x remains: 1.6017913818359375

### Step 5: Fourth Iteration (i = 4)

1. Square x: x² = 1.6017913818359375² ≈ 2.5657
2. Is x² ≥ 2? Yes (2.5657 > 2)
3. Add current bit to result: 0.5 + 0.0625 = 0.5625
4. Divide x² by 2: 2.5657 ÷ 2 ≈ 1.2829
5. New x ≈ 1.2829

### Continue for More Precision...

If we continue this process for a few more iterations:

- Fifth iteration: x² ≈ 1.646, No change, result remains 0.5625
- Sixth iteration: x² ≈ 2.71, Add 0.015625, result = 0.578125
- And so on...

### Final Result

After several iterations, the result converges to approximately 0.585, which is the correct fractional part of log₂(1.5).

## How This Maps to the Code

In the code:

```rust
while bit > 0 && precision < BIT_PRECISION {
    r *= r;  // Square r
    let is_r_more_than_two = r >> 127 as u32;  // Check if r² ≥ 2
    r >>= 63 + is_r_more_than_two;  // Normalize r again
    log2p_fraction_x64 += bit * is_r_more_than_two as i128;  // Add bit if r² ≥ 2
    bit >>= 1;  // Move to next bit
    precision += 1;  // Track precision
}
```

For our example with x = 1.5:
- First iteration: r² = 2.25, is_r_more_than_two = 1, add bit (0.5)
- Second iteration: r² = 1.265625, is_r_more_than_two = 0, don't add bit
- Third iteration: r² = 1.6017, is_r_more_than_two = 0, don't add bit
- Fourth iteration: r² = 2.5657, is_r_more_than_two = 1, add bit (0.0625)
- And so on...

This binary search approach efficiently converges to the fractional part of the logarithm, with each bit representing a power of 2 in the binary expansion of the result.


举例 ：
好的！让我们来看看如何将 **0.7** 这个小数转换成二进制。

### **步骤 1：乘以 2**

将 **0.7** 乘以 **2**，得到 **1.4**。

* **整数部分**是 **1**，记下 **1**。
* 剩余的小数部分是 **0.4**，继续进行下一步。

### **步骤 2：继续乘以 2**

将 **0.4** 乘以 **2**，得到 **0.8**。

* **整数部分**是 **0**，记下 **0**。
* 剩余的小数部分是 **0.8**，继续进行下一步。

### **步骤 3：继续乘以 2**

将 **0.8** 乘以 **2**，得到 **1.6**。

* **整数部分**是 **1**，记下 **1**。
* 剩余的小数部分是 **0.6**，继续进行下一步。

### **步骤 4：继续乘以 2**

将 **0.6** 乘以 **2**，得到 **1.2**。

* **整数部分**是 **1**，记下 **1**。
* 剩余的小数部分是 **0.2**，继续进行下一步。

### **步骤 5：继续乘以 2**

将 **0.2** 乘以 **2**，得到 **0.4**。

* **整数部分**是 **0**，记下 **0**。
* 剩余的小数部分是 **0.4**，这和步骤 2 中的小数部分一样，说明我们进入了循环。

### **结果**：

* 通过以上步骤，我们得到了二进制的小数部分：**0.1011**（重复循环）。

因此，**0.7** 的二进制表示是 **0.1011 (重复循环)**。

### **总结**：

* **0.7** 这个十进制小数在二进制中的表示是 **0.1011**，后面会重复 **1011**。这就是为什么某些十进制小数在二进制中无法完全精确表示，它们会进入一个 **循环**。

如果你有其他问题或者需要更多的示例，随时告诉我！
