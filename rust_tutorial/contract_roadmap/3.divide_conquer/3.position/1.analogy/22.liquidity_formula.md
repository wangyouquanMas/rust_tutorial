

参考链接：
https://github.com/raydium-io/raydium-docs/blob/master/dev-resources/raydium-clmm-dev-doc.pdf


1. The Mathematics of CLMM
L = sqrt(x*y)
sqrt(p) = sqrt(y/x)
L 表示流动性的数量. 在一个池子种，流动性是 token reserves的组合。 在CLMM种，L 是k 的square root.

为什么我们使用sqrt(P) 而不是P 是因为 squre root计算 is not precise 并且导致 rounding errors. 

Thus, 在合约种直接存储squre root而不用计算它，会更简单。 （在合约种我们不存储 x和y）

从上述公式种，我们可以deduce: 
x = L/sqrt(P)
y = L*sqrt(P)


2. Core Formula 
TODO: 图片1

在上述图片中，如果用户的流动性的指定范围是 [P_upper,P_lower], 使用x和y来代表token quantity的两个类型。这包含了
virtual 和 actual 添加的quantity, 同时它们也需要满足 x*y = k, the virtual流动性被表示为 x_virtual and y_virtual,
由用户添加的真实数量被表示为 deltaX and deltaY.
(deltaX + x_virtual) * (deltaY + y_virtual) = k. 
x_virtual的长度是在点p_upper的x轴长度， 然后 y_virtual的长度是点p_lower点y值。 

x_virtual = L/sqrt(P_upper) 
y_virtual = L*sqrt(P_lower)

So, it can be deduced that 
(deltax + L/sqrt(P_upper)) * (deltay + L*sqrt(P_lower)) = L^2

在公式中， p_upper 和 p_lower是已知的变量set by the user as the market making price range. 


3. Calculating Liquidity 
Price Range Calculation 
TODO: 图片2 

在该场景中，橙色部分是我们需要添加的真实流动性。 x,y是两种资产在当前价格对应的数量。 
delta_x = x - x_virtual
delta_y = y - y_virtual 
我们可以基于流动性L和price range来计算需要的delta_x 和 delta_y 
delta_x = L/sqrt(p) - L/sqrt(p_upper) = L * (sqrt(p_upper) - sqrt(p)) / (sqrt(p) * sqrt(p_upper))
delta_y = L*sqrt(p) - L*sqrt(p_lower) = L * (sqrt(p) - sqrt(p_lower))

如果我们还知道 price range 和 任意给定的 delta_x 或 delta_y，我们可以计算流动性L:
L = delta_x * (sqrt(p) * sqrt(p_upper)) / (sqrt(p_upper) - sqrt(p))
L = delta_y / sqrt(p-p_lower)


4. Price Out Range Calculation 
p>p_upper
TODO: 图3

在该情况下， 资产x的数量是0，同时所有的流动性变成 asset Y， 资产y的数量是 p_upper和p_lower的在y轴上的距离。 
也就是图中的紫色点线图部分。 基于delta_y, 我们可以计算 L:
L = delta_y / sqrt(p_upper - p_lower)

p<p_lower
TODO: 图4
在该情况下，asset Y的数量是0， 同时流动性被fully transformed into assetX, 它的数量是x轴上 p_upper 到p_lower的距离。 
我们可以计算L基于 delta_x :
L = delta_x *(sqrt(p_upper) * sqrt(plower)/sqrt(p_upper)-sqrt(p_lower))


















The formula used to calculate liquidity in the provided code is:

$$
\Delta L = \frac{\Delta x \cdot \sqrt{P_{upper}} \cdot \sqrt{P_{lower}}}{\sqrt{P_{upper}} - \sqrt{P_{lower}}}
$$

Where:

* $\Delta L$ represents the change in liquidity (the result being computed).
* $\Delta x$ represents the change in token\_0 (the `amount_0` in the function).
* $P_{upper}$ and $P_{lower}$ are the upper and lower bounds of the price range, respectively.
* The square roots of these prices are represented as `sqrt_ratio_a_x64` and `sqrt_ratio_b_x64`.

### Breakdown of the function:

1. **Input parameters:**

   * `sqrt_ratio_a_x64` and `sqrt_ratio_b_x64` represent the square roots of the upper and lower price bounds (scaled by a factor of $2^{64}$, hence the `_x64` suffix).
   * `amount_0` represents the amount of token\_0.

2. **Step-by-step operations:**

   * The function first checks if `sqrt_ratio_a_x64` is larger than `sqrt_ratio_b_x64`. If it is, it swaps the values to ensure `sqrt_ratio_a_x64` always holds the smaller value.
   * Then, it calculates an intermediate value by multiplying `sqrt_ratio_a_x64` and `sqrt_ratio_b_x64`, and divides by the fixed point value $Q64$. This represents the term $\sqrt{P_{upper}} \cdot \sqrt{P_{lower}}$ divided by the fixed-point scaling factor.
   * Finally, the liquidity change $\Delta L$ is computed by multiplying `amount_0` with this intermediate value and dividing by the difference between the two price bounds, $\sqrt{P_{upper}} - \sqrt{P_{lower}}$.

### The formula is derived from the general formula for liquidity in a constant product market maker (CPMM) like Uniswap, where liquidity depends on the square roots of the price bounds and the amount of tokens involved.
