### 推理要点：为什么 2L ≥ 1 ⇒ 当前位 b₁ = 1

- 设 L = log₂(r) 且 L ∈ [0, 1)。我们要写出 L 的二进制小数：L = 0.b₁b₂b₃…₂。TODO: 小数的二进制
- 把小数左移一位：2L ∈ [0, 2)。此时最“整数位”（单位位）的值就是第一位小数 b₁。
- 因而 b₁ = ⌊2L⌋，即
  - 若 2L ≥ 1，则 ⌊2L⌋ = 1 ⇒ b₁ = 1
  - 若 2L < 1，则 ⌊2L⌋ = 0 ⇒ b₁ = 0
- 等价写法（连接到代码判定）：
  - 2L ≥ 1 ⇔ log₂(r²) ≥ 1 ⇔ r² ≥ 2
  - 所以用 “r² ≥ 2” 来判定当轮位是否为 1。

- 余数递推（供理解后续位）：令 f₁ = 2L − b₁（保证 f₁ ∈ [0,1)），下一位 b₂ = ⌊2f₁⌋，依此类推。

- 小例子：
  - L = 0.6 ⇒ 2L = 1.2 ⇒ b₁ = 1
  - L = 0.3 ⇒ 2L = 0.6 ⇒ b₁ = 0

- 结论：2L 的“是否跨过 1”正对应 b₁ 是否为 1；这就是用比较 r² 与 2 的原因。

- 关键点小结
  - b₁ = ⌊2L⌋，阈值为 1 ⇒ 2L ≥ 1 ⇔ b₁ = 1
  - 与代码中的 r² ≥ 2 判定严格等价
  - 通过 fᵢ = 2fᵢ₋₁ − bᵢ 保持值回到 [0,1)，逐位提取后续比特



就像 知道二进制最高位 位n,那么其值范围就可以大致确定为 [2^n, 2^n+1)
这就是反过来，每轮用恒等式 log2(r^2) = 2L，把小数放大一位；判断 r^2 ≥ 2 等价于 2L ≥ 1 ⇒ 当前位 b_i = 1。



问题： 什么是，最”整数位“？ TODO: 重点
含义澄清：最“整数位”（单位位）
在二进制表示里，紧挨着小数点左侧的那一位就是“单位位”（2^0 位，也叫整数部分的最低位）。它的取值只有 0 或 1。
对任意 x∈[0,2)，x 的“单位位”就是 ⌊x⌋（x 的整数部分）。
应用到本题：
设 L = 0.b1 b2 b3…₂（L∈[0,1)）
左移一位（乘 2）：2L = b1 . b2 b3…₂
此时 2L 的“单位位”（整数部分）就是 b1，所以 b1 = ⌊2L⌋
若 2L ≥ 1，则单位位为 1 ⇒ b1=1
若 2L < 1，则单位位为 0 ⇒ b1=0
简例：
L = 0.101₂ (=0.625) ⇒ 2L = 1.01₂，单位位是 1 ⇒ b1=1
L = 0.011₂ (=0.375) ⇒ 2L = 0.11₂，单位位是 0 ⇒ b1=0
结论：这里“最整数位（单位位）的值”就是“乘 2 后结果的整数部分（floor）”，它恰好等于当前要判定的第一位小数 b1。