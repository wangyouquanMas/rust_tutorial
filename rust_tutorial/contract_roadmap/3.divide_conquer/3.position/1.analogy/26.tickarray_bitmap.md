目标：
1. tickarray bitmap的定义
2. tickarray bitmap的作用？
3. bitmap应用实例
4. bitmap中存储的是什么？ 
5. 对于一个tickarray来说，是否initialized是通过什么判断的？
6. tickarray状态是什么时候被存储到bitmap中的？ 怎么存储的？


内容：
1. 定义
A compact bitset per pool that tracks which tick arrays (60-tick chunks) are initialized.


It uses a 1024-bit map (represented via U1024 or arrays of u64) to mark each tick array within a bounded window around the current price.

Constants:
TICK_ARRAY_SIZE = 60
TICK_ARRAY_BITMAP_SIZE = 512 arrays per bitmap window
One bitmap window covers max_tick_in_tickarray_bitmap = tick_spacing × 60 × 512 ticks.

1.1. 数据结构，并解释字段参数含义
pub type TickArryBitmap = [u64; 8];
This creates a 512-bit bitmap (8 × 64 bits) that can track the initialization status of tick arrays.




2. 作用
Maps a tick array start index to a bit position, and:
    Checks if the current tick array is initialized.
    Finds the next initialized tick array in the swap direction using bit operations over the 1024-bit map.

The bitmap works by mapping tick indices to bit positions:
Base formula: compressed = tick_current / (tick_spacing × TICK_ARRAY_SIZE) + 512
Bit position: bit_pos = compressed.abs()
Range: Each bitmap covers TICK_ARRAY_BITMAP_SIZE × TICK_ARRAY_SIZE × tick_spacing ticks



3. 示例
I'll help you understand how the `tickArrayBitmap` works by walking through a concrete example. Let me first examine the test cases to see some real examples.

Read file: raydium-amm-v3/programs/amm/src/libraries/tick_array_bit_map.rs
Read file: raydium-amm-v3/programs/amm/src/libraries/tick_array_bit_map.rs
Now let me create a comprehensive example to help you understand how the `tickArrayBitmap` works:

## Example: How TickArrayBitmap Checks Initialization Status

Let me walk you through a concrete example using the test case from the code:

### **Setup**
- **Tick Spacing**: 10
- **Tick Array Size**: 60 ticks per array
- **Multiplier**: 10 × 60 = 600 ticks per array

### **Example 1: Checking if Tick 600 is Initialized**

Let's say we want to check if the tick array containing tick 600 is initialized:

```rust
let tick_current = 600;
let tick_spacing = 10;
let multiplier = 10 * 60 = 600;
```

**Step 1: Calculate compressed index**
```rust
let mut compressed = tick_current / multiplier + 512;
// compressed = 600 / 600 + 512 = 1 + 512 = 513
```

**Step 2: Get bit position**
```rust
let bit_pos = compressed.abs(); // bit_pos = 513
```

**Step 3: Create mask and check bit**
```rust
let mask = U1024::one() << 513;  // Set bit 513
let masked = bit_map & mask;     // Check if bit 513 is set
let initialized = masked != U1024::default(); // Is it initialized?
```

**Step 4: Return result**
```rust
return Ok((initialized, (compressed - 512) * multiplier));
// return Ok((initialized, (513 - 512) * 600));
// return Ok((initialized, 600)); // Start index of the tick array
```

### **Example 2: Real Bitmap Values**

From the test case, here's a real bitmap:
```rust
let bit_map: [u64; 16] = [
    1,                    // Bit 0 is set (tick array starting at -307200)
    0,                    // Bit 1 is not set
    0,                    // Bit 2 is not set
    0,                    // Bit 3 is not set
    0,                    // Bit 4 is not set
    0,                    // Bit 5 is not set
    9223372036854775808,  // Bit 63 is set (tick array starting at -38400)
    16140901064495857665, // Bits 0, 6, 7, 63 are set
    7,                    // Bits 0, 1, 2 are set
    1,                    // Bit 0 is set
    0,                    // No bits set
    0,                    // No bits set
    0,                    // No bits set
    0,                    // No bits set
    0,                    // No bits set
    9223372036854775808,  // Bit 63 is set
];
```

### **Example 3: Finding Next Initialized Array**

When searching for the next initialized tick array from tick 0:

**Direction: Down (zero_for_one = true)**
```rust
// Starting from tick 0, find next initialized array going down
let (is_found, array_start_index) = 
    next_initialized_tick_array_start_index(bit_map, 0, 10, true);
// Result: array_start_index = -600 (found at bit 511)
```

**Direction: Up (zero_for_one = false)**
```rust
// Starting from tick 0, find next initialized array going up
let (is_found, array_start_index) = 
    next_initialized_tick_array_start_index(bit_map, 0, 10, false);
// Result: array_start_index = 600 (found at bit 513)
```

### **Visual Representation**

```
Bitmap Index:    511  512  513  514  515  516  517  518  519  520
                 |    |    |    |    |    |    |    |    |    |
                 v    v    v    v    v    v    v    v    v    v
Tick Array:    [-600] [0] [600][1200][1800][2400][3000][3600][4200][4800]
                 |     |    |     |     |     |     |     |     |     |
Bit Value:      1     0    1     0     0     0     0     0     0     0
```

### **Key Insights**

1. **Bit 511** = Tick array starting at -600 (initialized)
2. **Bit 512** = Tick array starting at 0 (not initialized in this example)
3. **Bit 513** = Tick array starting at 600 (initialized)
4. **Bit 514** = Tick array starting at 1200 (not initialized)

### **Why This Works**

- **Efficient Storage**: Instead of storing 1024 boolean values, we store 1024 bits in 16 u64 values
- **Fast Lookup**: Bitwise operations are very fast on modern processors
- **Range Coverage**: Each bitmap can cover a huge range of tick indices
- **Memory Efficient**: 128 bytes can track thousands of tick arrays

This system allows Raydium to efficiently manage liquidity across a vast price range while keeping memory usage minimal and lookup times fast.


4. bitmap存储的是什么？
让我直接回答你的问题：**bitmap 中存储的是什么？**

## **Bitmap 中存储的是：TickArray 的初始化状态**

### **具体来说：**

1. **每一位 (bit) 代表一个 TickArray**
2. **位值含义**：
   - **Bit = 1**: 对应的 TickArray **已经初始化**
   - **Bit = 0**: 对应的 TickArray **尚未初始化**

### **存储结构：**

```rust
// tickArrayBitmap 是一个 1024 位的位图
pub type TickArryBitmap = [u64; 8];  // 8 × 64 = 512 bits

// 在 PoolState 中存储为
pub tick_array_bitmap: [u64; 16];    // 16 × 64 = 1024 bits
```

### **具体例子：**

假设我们有这样的 bitmap：
```
Bit 位置:    0    1    2    3    4    5    6    7    ...   511  512  513  514
TickArray: [-600][-300][0] [300][600][900][1200][1500] ... [600][900][1200][1500]
状态:       1    0    0    0    1    0    1    0     ...   1    0    1    0
```

**这意味着：**
- **Bit 0 = 1**: TickArray 起始于 -600 的 TickArray **已初始化**
- **Bit 1 = 0**: TickArray 起始于 -300 的 TickArray **未初始化**
- **Bit 4 = 1**: TickArray 起始于 600 的 TickArray **已初始化**
- **Bit 6 = 1**: TickArray 起始于 1200 的 TickArray **已初始化**

### **总结：**

**Bitmap 存储的不是 TickArray 的数据，而是 TickArray 的"存在性"或"初始化状态"的标记。**

- ✅ **存储**: TickArray 是否已初始化的布尔值
- ❌ **不存储**: TickArray 的具体内容、tick 数据、流动性信息等

这就像是一个"目录"或"索引"，告诉系统哪些 TickArray 已经创建，哪些还没有创建。

问题：bitmap的index和value分别对应什么？
让我通过查看代码来理解 bitmap 的 index 和 value 分别对应什么。

Search files...
基于代码分析，我现在可以清楚地回答你的问题：

## **Bitmap 的 Index 和 Value 分别对应什么？**

### **1. Bitmap Index (位索引)**

**Bitmap Index 对应的是：TickArray 的起始索引 (start_tick_index)**

#### **映射公式：**
```rust
let mut compressed = tick_current / multiplier + 512;
let bit_pos = compressed.abs();
```

#### **具体例子：**
```rust
// 假设 tick_spacing = 10, TICK_ARRAY_SIZE = 60
let multiplier = 10 * 60 = 600;

// Bit 511 对应 TickArray 起始于 -600
// Bit 512 对应 TickArray 起始于 0  
// Bit 513 对应 TickArray 起始于 600
// Bit 514 对应 TickArray 起始于 1200
```

#### **映射关系：**
```
Bitmap Index:    511  512  513  514  515  516
TickArray Start: -600  0    600  1200 1800 2400
```

### **2. Bitmap Value (位值)**

**Bitmap Value 对应的是：TickArray 的初始化状态**

#### **值含义：**
- **Value = 1**: 对应的 TickArray **已经初始化**
- **Value = 0**: 对应的 TickArray **尚未初始化**

#### **具体例子：**
```rust
let bit_map: [u64; 16] = [
    1,                    // Bit 0: TickArray 起始于 -307200 (已初始化)
    0,                    // Bit 1: TickArray 起始于 -306600 (未初始化)
    0,                    // Bit 2: TickArray 起始于 -306000 (未初始化)
    // ... 更多位
    1,                    // Bit 511: TickArray 起始于 -600 (已初始化!)
    0,                    // Bit 512: TickArray 起始于 0 (未初始化)
    1,                    // Bit 513: TickArray 起始于 600 (已初始化)
    // ... 更多位
];
```

### **3. 完整的对应关系**

```
Bitmap Index | TickArray Start Index | Bitmap Value | 状态
-------------|----------------------|--------------|-------
511          | -600                 | 1            | 已初始化
512          | 0                    | 0            | 未初始化  
513          | 600                  | 1            | 已初始化
514          | 1200                 | 0            | 未初始化
515          | 1800                 | 0            | 未初始化
516          | 2400                 | 1            | 已初始化
```

### **4. 为什么这样设计？**

#### **空间效率：**
- 用 1 位表示一个 TickArray 的状态
- 1024 位可以表示 1024 个 TickArray

#### **查询效率：**
- O(1) 时间复杂度检查特定 TickArray 是否初始化
- 通过位运算快速查找下一个/上一个已初始化的 TickArray

#### **数学保证：**
- 每个 TickArray 有唯一的起始索引
- 起始索引到 bitmap index 的映射是确定性的

### **总结：**

- **Bitmap Index**: 表示 TickArray 的起始索引位置
- **Bitmap Value**: 表示该 TickArray 是否已初始化 (1=已初始化, 0=未初始化)

这种设计让系统能够高效地跟踪和管理大量的 TickArray，而不需要存储每个 TickArray 的完整状态信息。





5. 对于一个tickarray来说，是否initialized是通过什么判断的？

让我查看代码来理解对于一个 TickArray 来说，"是否 initialized" 是通过什么判断的。

Search files...
基于代码分析，我现在可以清楚地回答你的问题：

## **对于一个 TickArray 来说，"是否 initialized" 是通过什么判断的？**

### **1. 判断标准：TickArray 账户是否被创建**

**TickArray 的 "initialized" 状态实际上是指：该 TickArray 的账户是否已经在区块链上被创建。**

### **2. 具体判断逻辑**

#### **在 Bitmap 层面：**
```rust
// 检查 bitmap 中对应位是否被设置
let mask = U1024::one() << bit_pos;
let masked = bit_map & mask;
let initialized = masked != U1024::default();
```

- **Bit = 1**: 表示该 TickArray 账户已经被创建（已初始化）
- **Bit = 0**: 表示该 TickArray 账户尚未被创建（未初始化）

#### **在账户层面：**
```rust
// 尝试加载 TickArray 账户
let tick_array_state = if tick_array_account_info.owner == &system_program::ID {
    // 账户不存在，需要创建
    create_or_allocate_account(...)
} else {
    // 账户已存在，直接加载
    AccountLoad::<TickArrayState>::try_from(&tick_array_account_info)?
};
```

### **3. 初始化过程**

#### **步骤 1: 创建账户**
```rust
pub fn initialize(
    &mut self,
    start_index: i32,
    tick_spacing: u16,
    pool_key: Pubkey,
) -> Result<()> {
    self.start_tick_index = start_index;
    self.pool_id = pool_key;
    self.recent_epoch = get_recent_epoch()?;
    Ok(())
}
```

#### **步骤 2: 设置 Bitmap 位**
```rust
// 将对应的 bitmap 位设置为 1
let mask = U512::one() << tick_array_offset_in_bitmap;
self.negative_tick_array_bitmap[offset] = tick_array_bitmap.bitxor(mask).0;
```

### **4. 为什么这样设计？**

#### **空间效率：**
- 不需要存储每个 TickArray 的完整状态
- 只需要 1 位就能表示一个 TickArray 是否存在

#### **查询效率：**
- O(1) 时间复杂度检查 TickArray 是否存在
- 快速找到下一个/上一个已初始化的 TickArray

#### **资源管理：**
- 只有在需要时才创建 TickArray 账户
- 避免创建大量未使用的账户

### **5. 实际例子**

```rust
// 假设我们要检查 TickArray 起始于 600 是否已初始化

// 1. 计算 bitmap 位置
let bit_pos = 513;  // 对应起始索引 600

// 2. 检查 bitmap 中第 513 位
if bit_map & (1 << 513) != 0 {
    // Bit 513 = 1，表示 TickArray 已初始化
    // 可以安全地加载该 TickArray 账户
} else {
    // Bit 513 = 0，表示 TickArray 未初始化
    // 需要先创建该 TickArray 账户
}
```

### **总结：**

**TickArray 的 "initialized" 状态实际上是一个双重概念：**

1. **逻辑层面**: Bitmap 中对应位是否被设置
2. **物理层面**: 区块链上是否已创建对应的 TickArray 账户

这种设计让系统能够：
- 高效地跟踪哪些 TickArray 已经存在
- 按需创建 TickArray 账户
- 快速查询和导航已初始化的 TickArray




6. tickarray状态是什么时候被存储到bitmap中的？ 怎么存储的？
让我查看代码来了解 TickArray 状态是什么时候被存储到 bitmap 中的，以及是如何存储的。

Search files...
让我继续搜索更多关于何时和如何存储 TickArray 状态到 bitmap 的信息。

Search files...
基于代码分析，我现在可以清楚地回答你的问题：

## **TickArray 状态是什么时候被存储到 bitmap 中的？**

### **1. 存储时机**

TickArray 状态在以下情况下被存储到 bitmap 中：

#### **A. 创建新位置时 (Open Position)**
```rust
// 在 open_position.rs 中
let tick_array_lower_loader = TickArrayState::get_or_create_tick_array(
    payer.to_account_info(),
    tick_array_lower_loader.to_account_info(),
    system_program.to_account_info(),
    &pool_state_loader,
    tick_array_lower_start_index,
    pool_state.tick_spacing,
)?;
```

#### **B. 增加流动性时 (Increase Liquidity)**
当用户向现有位置添加流动性时，如果涉及新的 TickArray，会创建并更新 bitmap。

#### **C. 减少流动性时 (Decrease Liquidity)**
```rust
// 在 decrease_liquidity.rs 中
if flip_tick_lower {
    let mut tick_array_lower = tick_array_lower_loader.load_mut()?;
    tick_array_lower.update_initialized_tick_count(false)?;
    if tick_array_lower.initialized_tick_count == 0 {
        // 当 TickArray 中没有已初始化的 tick 时，翻转 bitmap 位
        pool_state.flip_tick_array_bit(
            tickarray_bitmap_extension,
            tick_array_lower.start_tick_index,
        )?;
    }
}
```

#### **D. Swap 操作时**
```rust
// 在 swap.rs 中
for (tickarray_start_index, tick_array_info) in tick_array_map {
    tick_array_states.push_back(tick_array_info);
    pool_state
        .flip_tick_array_bit(Some(&bitmap_extension), tickarray_start_index)
        .unwrap();
}
```

### **2. 如何存储的？**

#### **A. 使用 `flip_tick_array_bit` 函数**
```rust
pub fn flip_tick_array_bit<'c: 'info, 'info>(
    &mut self,
    tickarray_bitmap_extension: Option<&'c AccountInfo<'info>>,
    tick_array_start_index: i32,
) -> Result<()> {
    if self.is_overflow_default_tickarray_bitmap(vec![tick_array_start_index]) {
        // 使用扩展 bitmap
        AccountLoader::<TickArrayBitmapExtension>::try_from(
            tickarray_bitmap_extension.unwrap(),
        )?
        .load_mut()?
        .flip_tick_array_bit(tick_array_start_index, self.tick_spacing)
    } else {
        // 使用核心 bitmap
        self.flip_tick_array_bit_internal(tick_array_start_index)
    }
}
```

#### **B. 核心 Bitmap 更新**
```rust
fn flip_tick_array_bit_internal(&mut self, tick_array_start_index: i32) -> Result<()> {
    let tick_array_offset_in_bitmap = self.get_tick_array_offset(tick_array_start_index)?;
    
    let tick_array_bitmap = U1024(self.tick_array_bitmap);
    let mask = U1024::one() << tick_array_offset_in_bitmap.try_into().unwrap();
    
    // 使用 XOR 操作翻转位
    self.tick_array_bitmap = tick_array_bitmap.bitxor(mask).0;
    Ok(())
}
```

#### **C. 扩展 Bitmap 更新**
```rust
pub fn flip_tick_array_bit(
    &mut self,
    tick_array_start_index: i32,
    tick_spacing: u16,
) -> Result<()> {
    let (offset, tick_array_bitmap) = self.get_bitmap(tick_array_start_index, tick_spacing)?;
    let tick_array_offset_in_bitmap = Self::tick_array_offset_in_bitmap(tick_array_start_index, tick_spacing);
    
    let tick_array_bitmap = U512(tick_array_bitmap);
    let mask = U512::one() << tick_array_offset_in_bitmap;
    
    if tick_array_start_index < 0 {
        // 负索引使用 negative_tick_array_bitmap
        self.negative_tick_array_bitmap[offset as usize] = tick_array_bitmap.bitxor(mask).0;
    } else {
        // 正索引使用 positive_tick_array_bitmap
        self.positive_tick_array_bitmap[offset as usize] = tick_array_bitmap.bitxor(mask).0;
    }
    Ok(())
}
```

### **3. 存储逻辑**

#### **A. 位翻转机制**
- **初始状态**: 所有位都是 0（未初始化）
- **创建 TickArray**: 对应位从 0 翻转为 1（已初始化）
- **删除 TickArray**: 对应位从 1 翻转为 0（未初始化）

#### **B. XOR 操作**
```rust
// 使用 XOR 操作翻转特定位
let mask = U1024::one() << bit_position;
let new_bitmap = old_bitmap.bitxor(mask);
```

**XOR 操作的效果：**
- `0 ^ 1 = 1` (未初始化 → 已初始化)
- `1 ^ 1 = 0` (已初始化 → 未初始化)

### **4. 存储位置**

#### **A. 核心 Bitmap**
```rust
// 在 PoolState 中
pub tick_array_bitmap: [u64; 16];  // 1024 bits
```

#### **B. 扩展 Bitmap**
```rust
// 在 TickArrayBitmapExtension 中
pub positive_tick_array_bitmap: [[u64; 8]; 14];  // 14 × 512 bits
pub negative_tick_array_bitmap: [[u64; 8]; 14];  // 14 × 512 bits
```

### **总结：**

**TickArray 状态存储到 bitmap 的时机：**
1. **创建新位置时**
2. **增加/减少流动性时**
3. **Swap 操作时**
4. **任何需要创建或删除 TickArray 的操作时**

**存储方式：**
1. **使用 XOR 操作翻转特定位**
2. **根据 tick 索引范围选择核心或扩展 bitmap**
3. **实时更新，确保 bitmap 与实际 TickArray 状态同步**

这种设计确保了 bitmap 能够准确反映当前系统中所有 TickArray 的初始化状态，为高效的流动性查询和导航提供支持。


6.1 这些对应位是怎么计算的？ 【Bitmap Index 的计算方法】
让我详细解释 bitmap 中每个 index 是如何计算的，以及它们的具体含义。

## **6.1 Bitmap Index 的计算方法**

### **1. 核心计算公式**

```rust
let mut compressed = tick_current / multiplier + 512;
let bit_pos = compressed.abs();
```

其中：
- `multiplier = tick_spacing × TICK_ARRAY_SIZE`
- `TICK_ARRAY_SIZE = 60`
- `+ 512` 是为了处理负数和正数的偏移

### **2. 具体计算步骤**

#### **步骤 1: 计算 TickArray 的起始索引**
```rust
// 对于任意 tick，计算它属于哪个 TickArray
let tick_array_start = (tick_current / multiplier) * multiplier;
```

#### **步骤 2: 计算在 Bitmap 中的位置**
```rust
let mut compressed = tick_array_start / multiplier + 512;
let bit_pos = compressed.abs();
```

### **3. 实际例子**

#### **例子 1: tick_spacing = 10, tick_current = 600**

```rust
let tick_spacing = 10;
let TICK_ARRAY_SIZE = 60;
let multiplier = 10 × 60 = 600;

// 步骤 1: 计算 TickArray 起始索引
let tick_array_start = (600 / 600) × 600 = 1 × 600 = 600;

// 步骤 2: 计算 bitmap 位置
let compressed = 600 / 600 + 512 = 1 + 512 = 513;
let bit_pos = 513;

// 结果: Bit 513 代表起始索引为 600 的 TickArray
```

#### **例子 2: tick_spacing = 10, tick_current = 1200**

```rust
let tick_spacing = 10;
let TICK_ARRAY_SIZE = 60;
let multiplier = 10 × 60 = 600;

// 步骤 1: 计算 TickArray 起始索引
let tick_array_start = (1200 / 600) × 600 = 2 × 600 = 1200;

// 步骤 2: 计算 bitmap 位置
let compressed = 1200 / 600 + 512 = 2 + 512 = 514;
let bit_pos = 514;

// 结果: Bit 514 代表起始索引为 1200 的 TickArray
```

#### **例子 3: tick_spacing = 10, tick_current = -600**

```rust
let tick_spacing = 10;
let TICK_ARRAY_SIZE = 60;
let multiplier = 10 × 60 = 600;

// 步骤 1: 计算 TickArray 起始索引
let tick_array_start = (-600 / 600) × 600 = -1 × 600 = -600;

// 步骤 2: 计算 bitmap 位置
let compressed = -600 / 600 + 512 = -1 + 512 = 511;
let bit_pos = 511;

// 结果: Bit 511 代表起始索引为 -600 的 TickArray
```

### **4. 负数的特殊处理**

```rust
if tick_current < 0 && tick_current % multiplier != 0 {
    // 向负无穷方向取整
    compressed -= 1;
}
```

#### **例子: tick_current = -300**

```rust
let tick_spacing = 10;
let TICK_ARRAY_SIZE = 60;
let multiplier = 10 × 60 = 600;

// 步骤 1: 计算 TickArray 起始索引
let tick_array_start = (-300 / 600) × 600 = 0 × 600 = 0;

// 步骤 2: 计算 bitmap 位置
let mut compressed = -300 / 600 + 512 = 0 + 512 = 512;

// 步骤 3: 负数特殊处理
if -300 < 0 && -300 % 600 != 0 {
    compressed -= 1;  // 512 - 1 = 511
}

let bit_pos = 511;

// 结果: Bit 511 代表起始索引为 -600 的 TickArray
```

### **5. 完整的映射关系表**

| Bit Index | TickArray Start Index | 计算过程 | 说明 |
|-----------|----------------------|----------|------|
| 0         | -307200              | (-307200/600) + 512 = -512 + 512 = 0 | 最负的 TickArray |
| 511       | -600                 | (-600/600) + 512 = -1 + 512 = 511 | 负索引边界 |
| 512       | 0                    | (0/600) + 512 = 0 + 512 = 512 | 零索引 |
| 513       | 600                  | (600/600) + 512 = 1 + 512 = 513 | 第一个正索引 |
| 514       | 1200                 | (1200/600) + 512 = 2 + 512 = 514 | 第二个正索引 |
| 1023      | 306600               | (306600/600) + 512 = 511 + 512 = 1023 | 最正的 TickArray |

### **6. 为什么这样设计？**

#### **A. 对称性**
- **Bit 0-511**: 表示负索引 TickArray
- **Bit 512**: 表示零索引 TickArray  
- **Bit 513-1023**: 表示正索引 TickArray

#### **B. 连续性**
- 相邻的 bit 对应相邻的 TickArray
- 便于查找下一个/上一个已初始化的 TickArray

#### **C. 数学一致性**
- 使用统一的公式处理正负索引
- 避免复杂的条件判断

### **7. 验证计算**

#### **验证 Bit 513 对应 TickArray 起始于 600**
```rust
// 反向计算
let tick_array_start = (bit_pos - 512) × multiplier;
let tick_array_start = (513 - 512) × 600 = 1 × 600 = 600;

// 验证成功！
```

#### **验证 Bit 511 对应 TickArray 起始于 -600**
```rust
// 反向计算
let tick_array_start = (bit_pos - 512) × multiplier;
let tick_array_start = (511 - 512) × 600 = -1 × 600 = -600;

// 验证成功！
```

### **总结：**

**Bitmap Index 的计算逻辑：**

1. **基础公式**: `compressed = tick_array_start / (tick_spacing × 60) + 512`
2. **负数处理**: 向负无穷方向取整
3. **最终位置**: `bit_pos = compressed.abs()`

**每个 Index 的含义：**
- **Index 0-511**: 负索引 TickArray（从 -307200 到 -600）
- **Index 512**: 零索引 TickArray（从 0 开始）
- **Index 513-1023**: 正索引 TickArray（从 600 到 306600）

这种设计确保了每个 TickArray 都有唯一的 bitmap 位置，并且位置与 TickArray 的起始索引有直接的数学关系。
