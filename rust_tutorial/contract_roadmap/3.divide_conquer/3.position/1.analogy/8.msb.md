目标：
1. 理解msb定义
2. 理解msb在计算logarithm in base2 for a give number 的整数部分的作用


内容：
1. 定义
The Most Significant Bit (MSB) is the highest set bit (the leftmost 1) in the binary representation of a number. It gives you the position of the largest power of 2 that is smaller than or equal to the number. This position is directly related to the integer part of the base 2 logarithm of the number.

2. 作用
How Does MSB Relate to log2(n)?
For a number n, the integer part of log2(n) corresponds to the position of the MSB.

Example 1: n = 8
Binary Representation: 1000

The highest 1 bit is at position 3 (0-based index).

So, the integer part of log2(8) is 3, because 
log
⁡
2
(
8
)
=
3
log 
2
​
 (8)=3.






# What is MSB (Most Significant Bit)? A Simple Explanation

The Most Significant Bit (MSB) is the bit position in a binary number that has the highest value - essentially, it's the leftmost "1" in the binary representation.

## Simple Example

Let's take the decimal number 42:

1. In binary, 42 is represented as: `101010`
2. Reading from right to left, the bits represent: 2⁰, 2¹, 2², 2³, 2⁴, 2⁵
3. The bits that are "on" (set to 1) are: 2¹, 2³, and 2⁵
4. The highest power of 2 that's "on" is 2⁵ = 32
5. Therefore, the MSB is at position 5 (counting from 0)

Visually:
```
Binary:  1  0  1  0  1  0
Position: 5  4  3  2  1  0
Value:   32 16  8  4  2  1
```

The MSB is the bit at position 5, which represents the value 32.

## In the Code Context

In the code:
```rust
let msb: u32 = 128 - sqrt_price_x64.leading_zeros() - 1;
```

This calculates the position of the most significant bit by:
1. Counting how many leading zeros are in the number
2. Subtracting that from the total number of bits (128 for a u128)
3. Subtracting 1 to get a zero-indexed position

For example, if we have the number 8 (binary: `1000`):
- In a u128, this would have 124 leading zeros
- MSB = 128 - 124 - 1 = 3
- This correctly identifies that the highest bit is at position 3 (2³ = 8)

The MSB is important in the tick calculation because it gives us a quick way to find the approximate logarithm base 2 of a number, which is the first step in calculating the tick index from a square root price.




Logarithm Decomposition Strategy
When calculating logarithms in fixed-point arithmetic, a common approach is to split the calculation into two parts:
Integer portion: The whole number part of the logarithm
Fractional portion: The decimal part of the logarithm
This two-step approach provides both efficiency and precision.
1. 如何计算整数部分？

2. 如何计算小数部分?

Example of the Two-Step Process
For a value like 10.75:
Integer portion: log₂(10.75) ≈ 3 (since 2³ = 8 < 10.75 < 16 = 2⁴)
Fractional portion: log₂(10.75) - 3 ≈ 0.4262...
The code calculates these separately:
MSB gives the approximate integer part
The iterative loop that follows calculates the fractional part




