目标：
1. 理解tick initialization的方法之一：modify position 
2. 理解modify position的调用时机

内容:
1. modify position 在初始化tick 流动性中的作用

1) It's the core routine that applies a liquidity delta to a position's ticks and pool 


- Triggers first-time tick init: calls TickState::update on lower/upper when liquidity_delta ≠ 0. If liquidity_gross was 0, update flips the tick to initialized (sets fee/reward outside snapshots, sets liquidity_gross > 0, updates liquidity_net).、

- Surfaces init events: returns (flip_tick_lower, flip_tick_upper) so the caller can persist the ticks and update array bookkeeping (increment initialized_tick_count; flip bitmap bit for the tick array if it was empty).

- Also computes token amounts for the liquidity change and updates pool active liquidity if the price is inside the range.


2) initialize tick
modify_position doesn’t set fields directly; it calls update_position, which updates each bound tick via TickState::update. If this is the first time (liquidity_gross was 0), the tick “flips” to initialized and snapshots are set.


问题：update的是什么？ bound tick是什么? 

    // update the ticks if liquidity delta is non-zero
    if liquidity_delta != 0 {
        // Update tick state and find if tick is flipped
        flipped_lower = tick_lower_state.update(
            pool_state.tick_current,
            liquidity_delta,
            pool_state.fee_growth_global_0_x64,
            pool_state.fee_growth_global_1_x64,
            false,
            &updated_reward_infos,
        )?;
        flipped_upper = tick_upper_state.update(
            pool_state.tick_current,
            liquidity_delta,
            pool_state.fee_growth_global_0_x64,
            pool_state.fee_growth_global_1_x64,
            true,
            &updated_reward_infos,
        )?;
    }


   /// Updates a tick and returns true if the tick was flipped from initialized to uninitialized
    pub fn update(
        &mut self,
        tick_current: i32,
        liquidity_delta: i128,
        fee_growth_global_0_x64: u128,
        fee_growth_global_1_x64: u128,
        upper: bool,
        reward_infos: &[RewardInfo; REWARD_NUM],
    ) -> Result<bool> {
        let liquidity_gross_before = self.liquidity_gross;
        let liquidity_gross_after =
            liquidity_math::add_delta(liquidity_gross_before, liquidity_delta)?;

        // Either liquidity_gross_after becomes 0 (uninitialized) XOR liquidity_gross_before
        // was zero (initialized)
        let flipped = (liquidity_gross_after == 0) != (liquidity_gross_before == 0);
        if liquidity_gross_before == 0 {
            // by convention, we assume that all growth before a tick was initialized happened _below_ the tick
            if self.tick <= tick_current {
                self.fee_growth_outside_0_x64 = fee_growth_global_0_x64;
                self.fee_growth_outside_1_x64 = fee_growth_global_1_x64;
                self.reward_growths_outside_x64 = RewardInfo::get_reward_growths(reward_infos);
            }
        }

        self.liquidity_gross = liquidity_gross_after;

        // when the lower (upper) tick is crossed left to right (right to left),
        // liquidity must be added (removed)
        self.liquidity_net = if upper {
            self.liquidity_net.checked_sub(liquidity_delta)
        } else {
            self.liquidity_net.checked_add(liquidity_delta)
        }
        .unwrap();
        Ok(flipped)
    }
