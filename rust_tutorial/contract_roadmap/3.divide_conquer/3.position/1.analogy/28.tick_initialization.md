参考信息源： https://app.uniswap.org/whitepaper-v3.pdf

目标：
1. 理解tick什么时候初始化？
2. 理解哪些tick可以被初始化？
3. 如何判断是否已经初始化了？

内容：
1. tick初始化时机
when liquidity is added to a range, if one or both of the ticks is not already used as a bound in 
an existing position, that tick is initialized. 

1.1 代码示例 TODO:
On first add to a bound, the tick is initialized:
    // get tick_state
    let mut tick_lower_state = *tick_array_lower_loader
        .load_mut()?
        .get_tick_state_mut(tick_lower_index, pool_state.tick_spacing)?;
    let mut tick_upper_state = *tick_array_upper_loader
        .load_mut()?
        .get_tick_state_mut(tick_upper_index, pool_state.tick_spacing)?;
    if tick_lower_state.tick == 0 {
        tick_lower_state.tick = tick_lower_index;
    }
    if tick_upper_state.tick == 0 {
        tick_upper_state.tick = tick_upper_index;
    }

Then modify_position calls TickState::update(...). If this is the first time (liquidity_gross was 0), update flips the tick to initialized (liquidity_gross > 0) and returns flip_tick_lower/upper = true.
The updates are persisted and accounting updated:
 let clock = Clock::get()?;
    let (amount_0, amount_1, flip_tick_lower, flip_tick_upper) = modify_position(
        i128::try_from(*liquidity).unwrap(),
        pool_state,
        protocol_position,
        &mut tick_lower_state,
        &mut tick_upper_state,
        clock.unix_timestamp as u64,
    )?;

    // update tick_state
    tick_array_lower_loader.load_mut()?.update_tick_state(
        tick_lower_index,
        pool_state.tick_spacing,
        tick_lower_state,
    )?;
    tick_array_upper_loader.load_mut()?.update_tick_state(
        tick_upper_index,
        pool_state.tick_spacing,
        tick_upper_state,
    )?;

    if flip_tick_lower {
        let mut tick_array_lower = tick_array_lower_loader.load_mut()?;
        let before_init_tick_count = tick_array_lower.initialized_tick_count;
        tick_array_lower.update_initialized_tick_count(true)?;

        if before_init_tick_count == 0 {
            pool_state.flip_tick_array_bit(
                tick_array_bitmap_extension,
                tick_array_lower.start_tick_index,
            )?;
        }
    }
    if flip_tick_upper {
        let mut tick_array_upper = tick_array_upper_loader.load_mut()?;
        let before_init_tick_count = tick_array_upper.initialized_tick_count;
        tick_array_upper.update_initialized_tick_count(true)?;

        if before_init_tick_count == 0 {
            pool_state.flip_tick_array_bit(
                tick_array_bitmap_extension,
                tick_array_upper.start_tick_index,
            )?;
        }
    }

1.2 验证方法2： 当初始化open position时候，哪些元素参与到tick 的初始化？






2. 哪些tick可以被初始化？
Not every tick can be initialized. The pool is instantiated with a parameter, tickSpacing(ts);
only ticks with indexes that are divisible by tickSpacing can be initialized. 

2.1 举例
For example, if tickSpacing is 2, then only even ticks (...04,02,0,2,4...)can be initialized. 

2.2 代码验证 
pub fn initialize(&mut self, tick: i32, tick_spacing: u16) -> Result<()> {
        if TickState::check_is_out_of_boundary(tick) {
            return err!(ErrorCode::InvalidTickIndex);
        }
        require!(
            tick % i32::from(tick_spacing) == 0,
            ErrorCode::TickAndSpacingNotMatch
        );
        self.tick = tick;
        Ok(())
    }

2.3 手动验证：实验8 tick / tickspacing 
>>> 134820/60
2247.0
>>> 134160/60
2236.0
>>> 135540/60
2259.0



3. 初始化判断依据
Definition of “initialized”:
    pub fn is_initialized(self) -> bool {
        self.liquidity_gross != 0
    }