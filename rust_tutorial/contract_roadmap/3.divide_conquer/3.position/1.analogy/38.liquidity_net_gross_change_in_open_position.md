目标：
1. 掌握当不同的LP的price range交叉时，tick内流动性的变化情况以及如何变化？


内容：
1. 变化




1.1 代码

#[zero_copy(unsafe)]
#[repr(C, packed)]
#[derive(Default, Debug)]
pub struct TickState {
    pub tick: i32,
    /// Amount of net liquidity added (subtracted) when tick is crossed from left to right (right to left)
    pub liquidity_net: i128,
    /// The total position liquidity that references this tick
    pub liquidity_gross: u128,

    /// Fee growth per unit of liquidity on the _other_ side of this tick (relative to the current tick)
    /// only has relative meaning, not absolute — the value depends on when the tick is initialized
    pub fee_growth_outside_0_x64: u128,
    pub fee_growth_outside_1_x64: u128,

    // Reward growth per unit of liquidity like fee, array of Q64.64
    pub reward_growths_outside_x64: [u128; REWARD_NUM],
    // Unused bytes for future upgrades.
    pub padding: [u32; 13],
}
在Raydium AMM V3中，每个tick都有两个关键的流动性字段：
liquidity_gross: 该tick上所有位置的总流动性（总是正数）
liquidity_net: 当价格跨越 【TODO: 跨越怎么理解？】该tick时，需要添加或移除的净流动性




1.2 具体场景分析
场景1：多个LP在相同价格范围添加流动性
假设有两个LP都在tick -184260 到 -173280 范围内添加流动性：
LP1: 添加 1000 流动性
LP2: 添加 2000 流动性

结果：
- tick -184260 (lower):
  - liquidity_gross: 3000 (1000 + 2000)
  - liquidity_net: +3000 (添加流动性)

- tick -173280 (upper):
  - liquidity_gross: 3000 (1000 + 2000)  
  - liquidity_net: -3000 (移除流动性)

场景2：LP在不同但重叠的价格范围添加流动性
LP1: tick -190000 到 -180000，流动性 1000
LP2: tick -185000 到 -175000，流动性 2000

结果：
- tick -190000 (LP1 lower):
  - liquidity_gross: 1000
  - liquidity_net: +1000

- tick -185000 (LP2 lower, LP1内部):
  - liquidity_gross: 2000
  - liquidity_net: +2000

- tick -180000 (LP1 upper, LP2内部):
  - liquidity_gross: 1000
  - liquidity_net: -1000

- tick -175000 (LP2 upper):
  - liquidity_gross: 2000
  - liquidity_net: -2000



1.2 实验


