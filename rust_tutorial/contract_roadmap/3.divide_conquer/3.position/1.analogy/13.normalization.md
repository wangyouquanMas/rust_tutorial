目标：
1. 理解什么是normalization
2. 理解normalization在get a fractional value中的作用？



目标：
1. 什么是normalization 


2. 理解其作用?











# Example of Normalization in the Log₂ Algorithm

Let me show you how the normalization process works with specific examples:

## The Normalization Code

```rust
let mut r = if msb >= 64 {
    sqrt_price_x64 >> (msb - 63)
} else {
    sqrt_price_x64 << (63 - msb)
};
```

This code normalizes the input value (`sqrt_price_x64`) so that it falls within the range [1,2) in Q64.64 fixed-point format.

## Example 1: Large Value Normalization

Let's say we have a value that's larger than 2:

### Input:
- `sqrt_price_x64 = 2^70` (which is 2^6 = 64 in actual value after accounting for x64 format)
- `msb = 70` (the highest bit is at position 70)

### Normalization:
Since `msb >= 64` is true (70 >= 64):
```
r = sqrt_price_x64 >> (msb - 63)
r = 2^70 >> (70 - 63)
r = 2^70 >> 7
r = 2^(70-7) = 2^63
```

In Q64.64 format:
- 2^63 represents the value 0.5 * 2^1 = 1.0
- This is exactly what we want: the value is now normalized to 1.0, which is in the range [1,2)

## Example 2: Medium Value Normalization

Let's try a value that's already between 1 and 2:

### Input:
- `sqrt_price_x64 = 2^64 * 1.5` (which is 1.5 in actual value)
- `msb = 64` (the highest bit is at position 64)

### Normalization:
Since `msb >= 64` is true (64 >= 64):
```
r = sqrt_price_x64 >> (msb - 63)
r = (2^64 * 1.5) >> (64 - 63)
r = (2^64 * 1.5) >> 1
r = 2^64 * 1.5 / 2 = 2^63 * 1.5
```

In Q64.64 format:
- 2^63 * 1.5 represents the value 0.5 * 2^1 * 1.5 = 1.0 * 1.5 = 1.5
- The value remains 1.5, which is already in the range [1,2)

## Example 3: Small Value Normalization

Now let's try a value that's smaller than 1:

### Input:
- `sqrt_price_x64 = 2^60` (which is 2^(60-64) = 2^-4 = 0.0625 in actual value)
- `msb = 60` (the highest bit is at position 60)

### Normalization:
Since `msb >= 64` is false (60 < 64):
```
r = sqrt_price_x64 << (63 - msb)
r = 2^60 << (63 - 60)
r = 2^60 << 3
r = 2^(60+3) = 2^63
```

In Q64.64 format:
- 2^63 represents the value 0.5 * 2^1 = 1.0
- The small value 0.0625 is normalized to 1.0, which is in the range [1,2)

## Visual Representation

Here's what's happening in binary for Example 3:

Original value (0.0625 in Q64.64):
```
0000 0000 0000 0001 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
   ^                                                                            
   bit 60                                                                       
```

After shifting left by 3 bits:
```
0000 0000 0000 1000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
            ^                                                                   
            bit 63 (represents 1.0 in Q64.64)                                  
```

## Why This Normalization Works

The normalization ensures that:

1. **For any input value**, the result `r` will have its most significant bit at position 63
2. **In Q64.64 format**, a value with its MSB at position 63 represents a number in the range [1,2)
3. **This range [1,2)** is exactly what the binary logarithm algorithm requires to work correctly

By normalizing the input to this range, we can apply the iterative squaring algorithm consistently, regardless of the original input's magnitude.

The shifting operation effectively:
- Divides large numbers by powers of 2 (right shift)
- Multiplies small numbers by powers of 2 (left shift)

This is equivalent to finding the "scientific notation" of the number in base 2, then adjusting it so the mantissa is in [1,2

).