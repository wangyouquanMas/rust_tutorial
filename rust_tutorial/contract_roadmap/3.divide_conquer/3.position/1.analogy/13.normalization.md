目标：
1. 理解什么是normalization
2. 理解normalization在get a fractional value中的作用？



目标：
1. 什么是normalization 


2. 理解其作用?











# Example of Normalization in the Log₂ Algorithm

Let me show you how the normalization process works with specific examples:

## The Normalization Code

```rust
let mut r = if msb >= 64 {
    sqrt_price_x64 >> (msb - 63)
} else {
    sqrt_price_x64 << (63 - msb)
};
```

This code normalizes the input value (`sqrt_price_x64`) so that it falls within the range [1,2) in Q64.64 fixed-point format.

## Example 1: Large Value Normalization

Let's say we have a value that's larger than 2:

### Input:
- `sqrt_price_x64 = 2^70` (which is 2^6 = 64 in actual value after accounting for x64 format)
- `msb = 70` (the highest bit is at position 70)

### Normalization:
Since `msb >= 64` is true (70 >= 64):
```
r = sqrt_price_x64 >> (msb - 63)
r = 2^70 >> (70 - 63)
r = 2^70 >> 7
r = 2^(70-7) = 2^63
```

In Q64.64 format:
- 2^63 represents the value 0.5 * 2^1 = 1.0
- This is exactly what we want: the value is now normalized to 1.0, which is in the range [1,2)

## Example 2: Medium Value Normalization

Let's try a value that's already between 1 and 2:

### Input:
- `sqrt_price_x64 = 2^64 * 1.5` (which is 1.5 in actual value)
- `msb = 64` (the highest bit is at position 64)

### Normalization:
Since `msb >= 64` is true (64 >= 64):
```
r = sqrt_price_x64 >> (msb - 63)
r = (2^64 * 1.5) >> (64 - 63)
r = (2^64 * 1.5) >> 1
r = 2^64 * 1.5 / 2 = 2^63 * 1.5
```

In Q64.64 format:
- 2^63 * 1.5 represents the value 0.5 * 2^1 * 1.5 = 1.0 * 1.5 = 1.5
- The value remains 1.5, which is already in the range [1,2)

## Example 3: Small Value Normalization

Now let's try a value that's smaller than 1:

### Input:
- `sqrt_price_x64 = 2^60` (which is 2^(60-64) = 2^-4 = 0.0625 in actual value)
- `msb = 60` (the highest bit is at position 60)

### Normalization:
Since `msb >= 64` is false (60 < 64):
```
r = sqrt_price_x64 << (63 - msb)
r = 2^60 << (63 - 60)
r = 2^60 << 3
r = 2^(60+3) = 2^63
```

In Q64.64 format:
- 2^63 represents the value 0.5 * 2^1 = 1.0
- The small value 0.0625 is normalized to 1.0, which is in the range [1,2)

## Visual Representation

Here's what's happening in binary for Example 3:

Original value (0.0625 in Q64.64):
```
0000 0000 0000 0001 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
   ^                                                                            
   bit 60                                                                       
```

After shifting left by 3 bits:
```
0000 0000 0000 1000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
            ^                                                                   
            bit 63 (represents 1.0 in Q64.64)                                  
```

## Why This Normalization Works

The normalization ensures that:

1. **For any input value**, the result `r` will have its most significant bit at position 63
2. **In Q64.64 format**, a value with its MSB at position 63 represents a number in the range [1,2)
3. **This range [1,2)** is exactly what the binary logarithm algorithm requires to work correctly

By normalizing the input to this range, we can apply the iterative squaring algorithm consistently, regardless of the original input's magnitude.

The shifting operation effectively:
- Divides large numbers by powers of 2 (right shift)
- Multiplies small numbers by powers of 2 (left shift)

This is equivalent to finding the "scientific notation" of the number in base 2, then adjusting it so the mantissa is in [1,2

).


3. Normalization的解释 [TODO: 核心点]
The normalization technique works because of how binary numbers and the most significant bit (msb) relate to the value range.

Here's why this approach converts the value to the range [0.5,1):

1. Understanding the msb:
   - The msb tells us the position of the highest '1' bit in the number
   - If a number has its msb at position n, its value is between 2^n and 2^(n+1) 【TODO: 核心点】

2. For large values (msb ≥ 64):
   - The code shifts right by (msb - 63) bits: `sqrt_price_x64 >> (msb - 63)` 
   - This is equivalent to dividing by 2^(msb-63)
   - Since the original value is between 2^msb and 2^(msb+1), after division it becomes:
     - Between 2^msb ÷ 2^(msb-63) and 2^(msb+1) ÷ 2^(msb-63)
     - Which simplifies to between 2^63 and 2^64
   - In a Q64.64 format, this represents a value between 0.5 and 1
   - But the code uses msb-63 (not msb-64), which makes the range [0.5,1)

3. For small values (msb < 64):
   - The code shifts left by (63 - msb) bits: `sqrt_price_x64 << (63 - msb)`
   - This is equivalent to multiplying by 2^(63-msb)
   - This brings the value up to have its msb at position 63
   - This again places the value in the range [0.5,1)

The key insight is that by shifting based on the msb position, we're essentially "moving the decimal point" to get the value into the desired range, which is a fundamental step for the binary logarithm algorithm that follows.




更新版：
如何将r规范化到区间[1,2) ? 
### 结论
是的，这段代码把 `r` 规范化到了区间 [1, 2)（在 Q1.63 解释下）。

### 为什么
设 `v = sqrt_price_x64 > 0`，`msb = ⌊log2 v⌋`，则有
- 2^msb ≤ v < 2^(msb+1)

代码等价于把最高位移到第 63 位：
- 当 msb ≥ 64：r = v · 2^(63 − msb)
- 当 msb < 64： r = v · 2^(63 − msb)（左移同样是乘 2 的幂）

因此：
- 2^msb · 2^(63 − msb) ≤ r < 2^(msb+1) · 2^(63 − msb)
- 即 2^63 ≤ r < 2^64

把 `r` 按 Q1.63 解读为数值 r / 2^63，则
- 1 ≤ r/2^63 < 2
- 所以 `r ∈ [1, 2)`（上界 2 不取）

这正是把尾数规格化到 [1, 2) 的效果，方便后续平方得到 Q2.126 并做位测试与再归一化。

- 前提：`sqrt_price_x64` 非 0；若为 0，`msb` 无意义，算法不适用（在相关场景中不会出现）。 

- 小结
  - 通过把 `msb` 对齐到第 63 位，保证整数 r 落在 [2^63, 2^64)。
  - 在 Q1.63 的缩放下，即数值区间 [1, 2)。