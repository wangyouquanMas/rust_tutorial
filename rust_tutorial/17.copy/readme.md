目标：
1. 什么是copy() 
2. Copy 和 Clone的区别？

内容：
1.什么是copy()?
copy() 是一个方法，用于类型实现了 Copy trait 时，自动执行值的浅拷贝（shallow copy）。这意味着当你复制一个实现了 Copy trait 的值时，实际上会将其“直接复制”，不需要像 clone() 那样显式创建一个新的对象。

如何使用?
copy() 方法并不是 Rust 的标准库中显式提供的函数，而是通过实现 Copy trait 来支持的。对于实现了 Copy trait 的类型，当你将一个变量赋值给另一个变量时，Rust 会自动进行拷贝。这种拷贝操作是隐式的，不需要显式调用 copy() 方法。

示例：
Copy 是 Rust 标准库中的一个 trait，它用于表示某个类型可以进行按位复制（shallow copy）。对于实现了 Copy trait 的类型，Rust 会在进行赋值时自动执行值拷贝。

一些常见的类型，如整数类型（i32, u64 等）、浮点数类型（f64）、布尔类型（bool）等，都会自动实现 Copy trait。

2. Copy 和 Clone的区别？
Copy trait：适用于可以通过简单的位复制进行拷贝的类型。例如，整数、浮点数和布尔类型，它们的值可以按字面意义复制而不需要创建新的堆分配对象。Copy 是隐式拷贝，Rust 在赋值时自动执行，不需要显式调用 copy()。

Clone trait：适用于需要执行深拷贝的类型。比如包含堆分配数据的类型（如 String, Vec<T> 等），它们的内存内容需要进行单独的拷贝操作。Clone 必须显式调用 .clone() 来生成副本。


3. Copy后的地址 vs Clone后的地址
let p1 = Point { x: 10, y: 20 };
let p2 = p1;
p1 和 p2 虽然值一样，但各自在栈上占了一段不同的位置。
这是 Rust 为了内存安全所做的设计 —— Copy 的副本是独立存在的，不会因为一个变量的改变而影响另一个。

let s1 = String::from("hello");
let s2 = s1.clone();
s1 和 s2 拥有相同的内容，但不同的堆地址和不同的结构体地址。
Copy 是对简单类型的自动化浅拷贝，Clone 是对复杂类型的显式深拷贝，但都是在创建独立副本。

4. Copy 和 Clone后的改动是否会影响原值？
Copy 的副本是独立存在的，不会因为一个变量的改变而影响另一个。
clone() 后的两个对象是完全独立的副本，不会相互影响。
| 特性   | `Copy`                | `Clone`                       |
| ---- | --------------------- | ----------------------------- |
| 拷贝类型 | 浅拷贝（栈上）               | 深拷贝（堆+栈）                      |
| 是否自动 | 是                     | 否，需手动 `.clone()`              |
| 是否独立 | 是                     | 是                             |
| 使用场景 | 简单数据（如 `i32`, `bool`） | 有堆数据的类型（如 `String`, `Vec<T>`） |
